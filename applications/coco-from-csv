#!/usr/bin/env python3
import os
import argparse
import json
import sys

from datetime import datetime
from io import StringIO

import cv2
import pandas as pd

DESCRIPTION = \
    """
Generate COCO JSON file from CSV file.

"""


def main():
    global ARGS
    ARGS = get_args()

    if not sys.stdin.isatty() and ARGS.csv is None:
        csv = StringIO(sys.stdin.read())
    else:
        csv = ARGS.csv

    if csv is None:
        raise IOError("No CSV file given")

    df = pd.read_csv(csv)
    if df.empty:
        if ARGS.fields is not None:
            df = pd.read_csv(csv, names=ARGS.fields.split(','), header=None)
        if df.empty:
            raise IOError("CSV headers were not provided or could not be inferred")

    if all(field in df for field in ['x1', 'x2', 'x3', 'x4']):
        coco_json = generate_from_retina_net(df)
    elif all(field in df for field in ['begin_frame', 'end_frame']):
        coco_json = generate_from_pide(df)

    json.dump(coco_json, sys.stdout, indent=4)
    say("done")
    sys.exit()


def generate_from_retina_net(df: pd.DataFrame):
    coco_json = {
        'info': {
            'year': int(datetime.now().year),
            'version': '1.0',
            'description': 'This is a dataset configured by Abyss Solutions.',
            'contributor': 'Abyss Solutions',
            'url': 'http://www.abysssolutions.com.au',
            'date_created': datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'),
        },
        'images': [],
        'annotations': [],
        'licenses': [],
    }

    if ARGS.map is not None:
        with open(ARGS.map, 'r') as file_handle:
            coco_json['categories'] = json.load(file_handle)['categories']

    seen_imgs = set()
    img_file_name_2_img_id = {}
    for idx, row in df.iterrows():
        category_id = int(row['category_id'])
        if category_id <= 0:
            continue

        img_path = row['file_name']
        img_file_name = os.path.basename(img_path)

        width = height = 0
        if img_file_name not in seen_imgs:
            seen_imgs.add(img_file_name)
            img_id = len(coco_json['images'])
            coco_json['images'].append({
                'id': img_id,
                'width': width,
                'height': height,
                'file_name': img_file_name,
                'license': 0,
                'date_captured': '',
                'path': img_path,
            })
            img_file_name_2_img_id[img_file_name] = img_id

        x = row['x1']
        y = row['y1']
        width = row['x2'] - x
        height = row['y2'] - y
        coco_json['annotations'].append({
            'id': len(coco_json['annotations']),
            'image_id': img_file_name_2_img_id[img_file_name],
            'category_id': category_id,
            'segmentation': None,
            'area': int(width * height),
            'bbox': [int(x), int(y), int(width), int(height)],
            'iscrowd': 0,
            'score': row['score'],
        })
    return coco_json


def generate_from_pide(df: pd.DataFrame):
    coco_json = {
        'file_name': '',
        'segments': [],
    }
    for idx, row in df.iterrows():
        if 'file_name' in row:
            coco_json['file_name'] = row['file_name']
        coco_json['segments'].append({
            'id': idx,
            'begin_frame': row['begin_frame'],
            'end_frame': row['end_frame'],
            'caption': row['caption'],
        })
    return coco_json

def get_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-c', '--csv', type=str, help="Path to CSV file.")
    parser.add_argument('-f', '--fields', type=str, help="Field headers for CSV file")
    parser.add_argument('-m', '--map', type=str, help="Path to JSON file of category and category ids")
    parser.add_argument('-v', '--verbose', action='store_true', help="More output to stderr")
    return parser.parse_args()


def say(*args, **kwargs):
    if ARGS.verbose:
        print("{}:".format(os.path.basename(__file__)), *args, file=sys.stderr, **kwargs)


if __name__ == '__main__':
    main()
