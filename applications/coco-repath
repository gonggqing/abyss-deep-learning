#!/usr/bin/python3

import argparse
import glob
import json
import os
import re
import sys
from inspect import currentframe
from pathlib import Path

import cv2
from pycocotools.coco import COCO

def recursive_search(video_basename: str, root_dir: str) -> str:
    """

    Args:
        video_basename: Base video file name
        root_dir: Root directory to search recursively in sub directories for video file

    Returns: Full file path to specified video base name

    """
    for file_path in glob.iglob(os.path.join(root_dir, "**", video_basename), recursive=True):
        return file_path

def main():
    args = get_args()

    if not args.video_dir:
        print("No video directory specified to search for video/s")
        sys.exit(1)

    #TODO: what are edge cases for this function isatty()?
    if not sys.stdin.isatty():
        for line in sys.stdin:
            args.json_files.append(line.strip())

    for json_file in args.json_files:
        print("Creating COCO object for {}".format(os.path.basename(json_file)))
        coco = COCO(json_file)

        print(json_file, args.video_dir)

        # if 'dataset' not in coco.dataset['info']: # Unsure if necessary 'if' statement
        cur_vid = coco.dataset['info']['dataset']['video']['uri']
        new_vid = recursive_search(os.path.basename(cur_vid), os.path.commonpath((cur_vid[::-1], new_vid[::-1]))[::-1])
        common_suffix = os.path.commonpath((cur_vid[::-1], new_vid[::-1]))[::-1]
        coco.dataset['info']['dataset']['video']['uri'] = new_vid

        if args.keep_segmentation:
            return NotImplementedError("Not yet implemented")

        for image in coco.dataset['images']:
            if 'original_uri' in image:
                old_ext = image['original_uri'].split('?')[-1]
                image['original_uri'] = '?'.join(new_vid, old_ext)

        # Write the new data set
        with open(os.path.join(json_file), 'w') as outfile:
            json.dump(coco.dataset, outfile, sort_keys=True, indent=4)

    sys.exit(0)


def debug_print(arg):
    """Debugging tool to print line number followed by normal print statement arguments

    """
    frame_info = currentframe()
    print('Line', frame_info.f_back.f_lineno, ':', arg)


def get_unique_list_of_videos(coco):
    """Gets a unique list of all videos in the dataset

    Args:
        coco (COCO): A coco dataset

    Returns:
        list: List of strings of all videos in the dataset

    """
    video_list = []
    img_ids = coco.getImgIds(imgIds=[])  # Load all images
    for img_id in img_ids:
        video_path = coco.loadImgs(img_id)[0]['path']
        # debug_print("video path is {}".format(video_path))
        video_name = os.path.basename(video_path).split(':')[0]
        video_name = re.sub(r' \([0-9]+\)', '', video_name)
        # debug_print(video_name)
        video_list.append(video_name)
    return list(set(video_list))


def recursive_search(video_basename: str, root_dir: str) -> str:
    """

    Args:
        video_basename: Base video file name
        root_dir: Root directory to search recursively in sub directories for video file

    Returns: Full file path to specified video base name

    """
    for file_path in glob.iglob(os.path.join(root_dir, "**", video_basename), recursive=True):
        return file_path


def get_args():
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("json_files", nargs='+', type=str, help="Path to JSON file")
    parser.add_argument("--video-dir", "--video", "-v", type=str,
                        help="Path under which all the videos referenced in JSON file(s) expected to be found")
    parser.add_argument("--output-dir", "--output", "-o", type=str,
                        help="Output directory path for database", default=os.getcwd())
    parser.add_argument("--keep-segmentation", "--seg", "-s", action='store_true',
                        help="Keep segmentation regions, otherwise assume to be classification task (and discard "
                             "regions)")
    # TODO: Check to see what differs between cloud factory format and other formats
    parser.add_argument("--cloud-factory", "--cloud", "-c", action="store_true",
                        help="Input JSON files are in (deprecated) cloud factory format flavour")
    parser.add_argument("--make-images", "--image", "-i", action="store_true",
                        help="Extract images from video and save as PNG")
    parser.add_argument("--relative-path", "--relative", "-r", action="store_true",
                        help="Image paths will be relative to the "
                             "coco.json file in output data set "
                             "directory")
    return parser.parse_args()


# TODO: check with seva & jackson on good way to do this
def translate_caption(input_format, label):
    return label


def remove_redundant_fields_in_coco(coco: COCO):
    """
    Filter old formatted COCO object to new format

    Args:
        coco: COCO object

    """
    remove_redundant_fields(coco.dataset, ['info', 'images', 'annotations'])
    for img in coco.dataset['images']:
        remove_redundant_fields(img, ["height", "width", "id", "path", "original_uri"])
    remove_redundant_fields(coco.dataset['info'], ["url",
                                                   "year",
                                                   "contributor",
                                                   "total_time",
                                                   "description",
                                                   "version",
                                                   "date_created",
                                                   "dataset",
                                                   ])


def remove_redundant_fields(dictionary: dict, fields: list):
    """

    Args:
        dictionary: Standard dictionary inside a COCO object
        fields: Fields of interest to keep

    """
    for field in list(dictionary):
        if field not in fields:
            del dictionary[field]


if __name__ == "__main__":
    main()
