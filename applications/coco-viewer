#!/usr/bin/env python3
from __future__ import print_function
from contextlib import redirect_stdout
from sys import stderr
import argparse
import json
import os
import sys

from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
from pycocotools import mask as COCOmask
from pycocotools.coco import COCO
from abyss_deep_learning.utils import imread
import matplotlib.pyplot as plt
import numpy as np


def bounding_box(polygon):
    'return the bounding box of a given polygon'
    min_x, min_y = np.min(polygon, axis=0)
    max_x, max_y = np.max(polygon, axis=0)
    return [(min_x, min_y), (min_x, max_y), (max_x, max_y), (max_x, min_y)]


def poly_from_bbox(bbox):
    min_x, min_y = bbox[0], bbox[1]
    max_x, max_y = bbox[0] + bbox[2], bbox[1] + bbox[3]
    return [(min_x, min_y), (min_x, max_y), (max_x, max_y), (max_x, min_y)]


def showAnns(self, anns, cat_map, use_bbox=False):
    """
    Display the specified annotations.
    :param anns (array of object): annotations to display
    :return: None
    """
    if len(anns) == 0:
        return 0
    if 'segmentation' in anns[0] or 'keypoints' in anns[0]:
        dataset_type = 'instances'
    elif 'caption' in anns[0]:
        dataset_type = 'captions'
    else:
        raise Exception('dataset_type not supported')
    if dataset_type == 'instances':
        axis = plt.gca()
        axis.set_autoscale_on(False)
        polygons = []
        color = []
        for ann in anns:
            c = (np.random.random((1, 3))*0.6+0.4).tolist()[0]
            if 'segmentation' in ann:
                if type(ann['segmentation']) == list:
                    # polygon
                    for seg in ann['segmentation']:
                        poly = np.array(seg).reshape((int(len(seg)/2), 2))
                        if use_bbox:
                            poly = poly_from_bbox(ann['bbox'])
                        polygons.append(Polygon(poly))
                        color.append(c)
                    axis.text(np.mean(poly[:, 0]), np.mean(poly[:, 1]), cat_map[ann['category_id']])
                else:
                    # mask
                    t = self.imgs[ann['image_id']]
                    if type(ann['segmentation']['counts']) == list:
                        rle = COCOmask.frPyObjects(
                            [ann['segmentation']], t['height'], t['width'])
                    else:
                        rle = [ann['segmentation']]
                    m = COCOmask.decode(rle)
                    img = np.ones((m.shape[0], m.shape[1], 3))
                    if ann['iscrowd'] == 1:
                        color_mask = np.array([2.0, 166.0, 101.0])/255
                    if ann['iscrowd'] == 0:
                        color_mask = np.random.random((1, 3)).tolist()[0]
                    for i in range(3):
                        img[:, :, i] = color_mask[i]
                    axis.imshow(np.dstack((img, m*0.5)))
            if 'keypoints' in ann and type(ann['keypoints']) == list:
                # turn skeleton into zero-based index
                sks = np.array(self.loadCats(
                    ann['category_id'])[0]['skeleton'])-1
                kp = np.array(ann['keypoints'])
                x = kp[0::3]
                y = kp[1::3]
                v = kp[2::3]
                for sk in sks:
                    if np.all(v[sk] > 0):
                        plt.plot(x[sk], y[sk], linewidth=3, color=c)
                plt.plot(x[v > 0], y[v > 0], 'o', markersize=8,
                         markerfacecolor=c, markeredgecolor='k', markeredgewidth=2)
                plt.plot(x[v > 1], y[v > 1], 'o', markersize=8,
                         markerfacecolor=c, markeredgecolor=c, markeredgewidth=2)
        p = PatchCollection(polygons, facecolor=color, linewidths=0, alpha=0.4)
        axis.add_collection(p)
        p = PatchCollection(polygons, facecolor='none',
                            edgecolors=color, linewidths=2)
        axis.add_collection(p)
    elif dataset_type == 'captions':
        for ann in anns:
            print(ann['caption'])


def info(string):
    print(string, file=stderr)


def foreach_coco_image(dataset, function):
    image_ids = dataset.getImgIds()
    images = dataset.loadImgs(image_ids)
    for image in images:
        annotations = dataset.loadAnns(dataset.getAnnIds(imgIds=[image['id']]))
        function(dataset, image, annotations)


def calculate_rgb_means(dataset, image_dir=None):
    '''Calculate the pixel color means in the dataset'''
    means = []
    def _calc_rgb(_dataset, image, _annotations):
        image_path = image['path'] if 'path' in image else os.path.join(
            image_dir, image['file_name'])
        print(image_path, file=sys.stderr)
        output_size = (image['height'], image['width'])
        rgb = imread(image_path, output_size=output_size)
        means.append(np.mean(rgb, axis=(0, 1)))
    foreach_coco_image(dataset, _calc_rgb)
    return np.mean(np.array(means), axis=0).tolist()


def coco_info(dataset, args):
    if args.verbose:
        print(args)
    db_info = {
        'num_images': len(dataset.imgs),
        'num_annotations': len(dataset.anns),
        'num_categories': len(dataset.cats),
        'category_names': [cat['name'] for cat in dataset.cats.values()],
        'category_ids': [cat['id'] for cat in dataset.cats.values()]
    }
    if args.rgb_means:
        db_info['rgb_means'] = calculate_rgb_means(
            dataset, image_dir=args.image_dir)
    print(json.dumps(db_info))


def main(args):
    with redirect_stdout(sys.stderr):
        coco_db = COCO(args.coco_path)
    args.info = True if args.rgb_means else args.info
    if args.info:
        coco_info(coco_db, args)
        exit(0)
    cat_map = {cat['id']: cat['name'] for cat in coco_db.loadCats(coco_db.getCatIds())}
    img_ids = coco_db.getImgIds(imgIds=args.ids, catIds=args.cats)
    # image_sets = [coco_db.getImgIds(catIds=cat) for cat in args.cats]
    # img_ids = list(set([j for i in image_sets for j in i]))
    images = coco_db.loadImgs(ids=img_ids)
    if not images:
        info("No images with given ids and cats")
        exit(0)
    info("Categories:")
    info(coco_db.loadCats(args.cats))
    info("Loaded {:d} images".format(len(images)))
    for _i, image in enumerate(images):
        plt.figure(figsize=(15, 11))
        image_path = image['path'] if 'path' in image else os.path.join(
            args.image_dir, image['file_name'])
        if not os.path.exists(image_path):
            image_path = os.path.join(args.image_dir, image_path)
        output_size = (image['height'], image['width'])
        rgb = imread(image_path, output_size=output_size)
        ann_ids = coco_db.getAnnIds(imgIds=[image['id']], catIds=args.cats)
        annotations = coco_db.loadAnns(ids=ann_ids)
        if not annotations:
            info("skipping {:s} cause of 0 annotations".format(
                image['file_name']))
        # remove duplicates
        #     groups = []
        #     uniquekeys = []
        #     data = sorted(annotations, key=lambda a: a['segmentation'])
        #     for k, g in itertools.groupby(data, lambda a: a['segmentation']):
        #         groups.append(list(g))      # Store group iterator as a list
        #         uniquekeys.append(k)
        #     annotations = [sorted(g, key=lambda a: a['id'])[0] for g in groups]
        info("[{:s} \"{:s}\"] %d annotations".format(
            str(image['id']), image['file_name'], len(annotations)))
        if not args.dontshow:
            plt.imshow(rgb)
            try:
                showAnns(coco_db, annotations, cat_map, use_bbox=False)
                plt.title("[{:s}] {:s}".format(
                    str(image['id']), image['file_name']))
            except Exception as e:
                print(e, file=stderr)
                plt.title("ERROR [{:s}] {:s}".format(
                    str(image['id']), image['file_name']))
            plt.show()


def get_args():
    '''Get args from the command line args'''
    parser = argparse.ArgumentParser(
        description="Extract labels from COCO JSON and dump them in to annotation images")
    parser.add_argument("coco_path", help="The coco JSON to parse.")
    parser.add_argument(
        "--ids", help="View this image ID, if not given then view all.", default='')
    parser.add_argument(
        "--cats", help="Filter images by categories, CSV-delimited", default='')
    parser.add_argument(
        "--dontshow", help="Filter images by categories, CSV-delimited", action='store_true')
    parser.add_argument(
        "--info", help="Print coco info and exit", action='store_true')
    parser.add_argument(
        "--rgb-means", help="Print coco rgb means (implies --info)", action='store_true')
    parser.add_argument(
        "--image-dir", help="If images referenced relatively, give the iamge dir", default='.')
    parser.add_argument(
        "--verbose", help="Print extra --info", action='store_true')
    args = parser.parse_args()
    args.ids = [int(i) for i in args.ids.split(',') if len(i)]
    args.cats = [int(i) for i in args.cats.split(',') if len(i)]
    return args


if __name__ == '__main__':
    main(get_args())
