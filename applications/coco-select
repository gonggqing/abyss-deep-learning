#!/usr/bin/env python3
import argparse
import copy
import json
import logging
import sys
import time
from collections import namedtuple

import pandas as pd

_DESCRIPTION = \
    """
Read COCO json file piped in from stdin and write to stdout COCO json output.

Select on two keywords image or annotation:
    if on == 'images':
        evaluate the expression on a per image basis and select all their associated annotations
        
    elif on == 'annotations':
        evaluate the expression on a per annotation basis and select the associated image

Generate an expression based on existing fields in COCO format
    annotations can be searched by
        a.id    Search by id
        a.bbox  Search by bbox
        a.area  Search by area
        etc
        
    images can be searched by
        i.id    Search by id
        i.path  Search by path
        i.width Search by width
        etc
        
    categories can be searched by
        c.id    Search by id
        c.name  Search by name

examples:
    cat pf.json | coco-select annotations "a.id == 4"
    cat pf.json | coco-select annotations "c.id == 4"
    cat pf.json | coco-select annotations "c.name == 'PF-H'"
    
    cat pf.json | coco-select images "c.name == 'PF-H'"
    cat pf.json | coco-select images "c.id == 4"   
"""


def main(args):
    logging.basicConfig(format='%(filename)s: %(asctime)s.%(msecs)d: %(levelname)s: %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S',
                        level=args.verbose)
    # pd.set_option('display.expand_frame_repr', False)
    tic = time.perf_counter()
    logging.info("Search expressions is [{}]".format(args.expression))

    # Empty file check
    buffer = sys.stdin.read().strip()
    if buffer:
        data = json.loads(buffer)
    else:
        logging.error("Expecting input from stdin: received empty characters {}".format(repr(buffer)))
        sys.exit(1)

    if args.on == 'annotations' and len(data['annotations']) == 0:
        logging.warning("Got empty annotations, input passed through to stdout")
        json.dump(data, sys.stdout, indent=args.indent)
        sys.exit(0)

    for annotation in data['annotations']:
        annotation['annotation_id'] = annotation.pop('id')

    if args.keep_images:
        original_images = copy.deepcopy(data['images'])  # quick and dirty, ugly

    for image in data['images']:
        image['image_id'] = image.pop('id')

    for category in data['categories']:
        category['category_id'] = category.pop('id')

    df_annotations = create_data_frame(data['annotations'])
    df_images = create_data_frame(data['images'])
    df_categories = create_data_frame(data['categories'])

    annotation_keys = df_annotations.keys()
    image_keys = df_images.keys()
    category_keys = df_categories.keys()

    logging.info("Joining annotations, categories and images")
    df = pd.merge(left=df_annotations, right=df_categories, on='category_id')
    df = pd.merge(left=df, right=df_images, on='image_id')

    Keys = namedtuple("Keys", ['ann_keys', 'img_keys', 'cat_keys'])
    keys = Keys(ann_keys=annotation_keys, img_keys=image_keys, cat_keys=category_keys)

    logging.info("Evaluating on {}".format(args.on))
    if args.on == 'images':
        df = eval_on(df, args, keys, 'image_id')
    elif args.on == 'annotations':
        df = eval_on(df, args, keys, 'annotation_id')

    images = []
    for record in df[image_keys].itertuples():
        images.append(record_to_dict(record, 'image_id'))

    annotations = []
    for record in df[annotation_keys].itertuples():
        annotations.append(record_to_dict(record, 'annotation_id'))

    categories = []
    for record in df[category_keys].itertuples():
        categories.append(record_to_dict(record, 'category_id'))

    data['annotations'] = drop_duplicates(annotations)
    data['images'] = original_images if args.keep_images else drop_duplicates(images)

    if args.keep_categories:
        for category in data['categories']:
            category['id'] = category.pop('category_id')
    else:
        data['categories'] = drop_duplicates(categories)

    logging.info("Printing to stdout")
    json.dump(data, sys.stdout, indent=args.indent)
    logging.info("Done in {elapsed_time}s".format(elapsed_time=time.perf_counter() - tic))
    sys.exit(0)


def create_data_frame(data: dict) -> pd.DataFrame:
    df = pd.DataFrame(data)
    values = {}
    invalid_values = []
    # TODO: Addressing NaN values, need to find specific JSON file that triggers error
    for column_name in df:
        try:
            values[column_name] = df[column_name].mode()[0]
        except IndexError:
            invalid_values.append(column_name)
        except TypeError:
            invalid_values.append(column_name)
    return df


def drop_duplicates(list_: list):
    def to_tuple(entry_: list):
        return tuple(to_tuple(i) if isinstance(i, list) else i for i in entry_)
    return [dict(item) for item in set(to_tuple([list(item) for item in sorted(entry.items())]) for entry in list_)]


def record_to_dict(record: namedtuple, re_id: str) -> dict:
    dict_ = record._asdict()
    dict_['id'] = dict_.pop(re_id)
    dict_.pop('Index')
    return dict_


def eval_on(df: pd.DataFrame, args: argparse.Namespace, keys: namedtuple, on_id: str) -> pd.DataFrame:
    ids = set()
    df_images = df[keys.img_keys].rename(index=str, columns={'image_id': 'id'})
    df_categories = df[keys.cat_keys].rename(index=str, columns={'category_id': 'id'})
    df_annotations = df[keys.ann_keys].rename(index=str, columns={'annotation_id': 'id'})

    if args.init is not None:
        eval(args.init)

    for a, i, c in zip(df_annotations.itertuples(), df_images.itertuples(), df_categories.itertuples()):
        idx = int(a.Index)
        if eval(args.expression):
            ids.add(df.iloc[idx][on_id])

    # Index later so that indexing into list doesn't go out of bounds as df shrinks
    df = df.loc[df[on_id].isin(ids)]
    return df


def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=_DESCRIPTION,
                                     formatter_class=argparse.RawDescriptionHelpFormatter, )
    parser.add_argument('on',
                        type=str,
                        choices={'images', 'annotations'},
                        help="How to search and select images and annotations. If on is 'image', then evaluate the "
                             "expression on a per image basis and for images that satisfy the expression, select all "
                             "associated annotations. If on is 'annotation', then evaluate the expression on a per "
                             "annotation basis and for annotations that satisfy the expression, select all associated "
                             "images.")
    parser.add_argument('expression', type=str, help="General expression to search for images.",)
    parser.add_argument('-i', '--init', type=str, help="General python code to run at the start of the script")
    parser.add_argument('-m', '--min', action='store_const', const=None, default=4, dest='indent', help="Disable JSON pretty print.")
    parser.add_argument('--keep-categories', action='store_true', help='Carry over all categories from original COCO JSON file.')
    parser.add_argument('--keep-images', action='store_true', help='Carry over all images from original COCO JSON file.')
    parser.add_argument('-v', '--verbose', action='store_const', const=logging.INFO, help="More output to stderr.")
    return parser.parse_args()


if __name__ == '__main__':
    main(get_args())

