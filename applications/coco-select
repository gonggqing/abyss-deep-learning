#!/usr/bin/env python3

__author__ = 'Kent Hu, and Seva'
__maintainer__ = 'Kent Hu'
import argparse
import copy
import json
import logging
import sys
import time
from collections import namedtuple

import pandas as pd

pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
pd.set_option('display.expand_frame_repr', False)
pd.set_option('max_colwidth', -1)

_DESCRIPTION = \
    """
Read COCO json file piped in from stdin and write to stdout COCO json output.

Select on two keywords image or annotation:
    if on == 'images':
        evaluate the expression on a per image basis and select all their associated annotations
        
    elif on == 'annotations':
        evaluate the expression on a per annotation basis and select the associated image

Generate an expression based on existing fields in COCO format
    annotations can be searched by
        a.id    Search by id
        a.bbox  Search by bbox
        a.area  Search by area
        etc
        
    images can be searched by
        i.id    Search by id
        i.path  Search by path
        i.width Search by width
        etc
        
    categories can be searched by
        c.id    Search by id
        c.name  Search by name

examples:
    cat pf.json | coco-select annotations "a.id == 4"
    cat pf.json | coco-select annotations "c.id == 4"
    cat pf.json | coco-select annotations "c.name == 'PF-H'"
    
    cat pf.json | coco-select images "c.name == 'PF-H'"
    cat pf.json | coco-select images "c.id == 4"   
"""


def main(args):
    logging.basicConfig(format='%(filename)s: %(asctime)s.%(msecs)d: %(levelname)s: %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S',
                        level=args.verbose)
    # pd.set_option('display.expand_frame_repr', False)
    tic = time.perf_counter()
    logging.info("Search expressions is [{}]".format(args.expression))

    # Empty file check
    buffer = sys.stdin.read().strip()
    if buffer:
        data = json.loads(buffer)
    else:
        logging.error("Expecting input from stdin: received empty characters {}".format(repr(buffer)))
        sys.exit(1)

    if args.on == 'annotations' and len(data.get('annotations', [])) == 0:
        logging.warning("Got empty annotations, input passed through to stdout")
        json.dump(data, sys.stdout, indent=args.indent)
        sys.exit(0)

    original_images = copy.deepcopy(data.get('images', [])) if args.keep_images else None  # quick and dirty, ugly

    for annotation in data.get('annotations', []):
        annotation['annotation_id'] = annotation.pop('id')

    for image in data.get('images', []):
        image['image_id'] = image.pop('id')

    for category in data.get('categories', []):
        category['category_id'] = category.pop('id')

    df_annotations = create_data_frame(data.get('annotations', []))
    df_images = create_data_frame(data.get('images', []))
    df_categories = create_data_frame(data.get('categories', []))

    annotation_keys = df_annotations.keys()
    image_keys = df_images.keys()
    category_keys = df_categories.keys()

    logging.info("Joining annotations, categories and images")
    try:
        df = pd.merge(left=df_annotations, right=df_categories, on='category_id')
    except KeyError:
        # Not point in having a category data frame as images do not contain a category id field
        df = df_annotations
    try:
        pass
    except KeyError:
        # Original df was df_annotations, if empty, then assign df_images
        df = df_images if df.empty else df
    df = pd.merge(left=df, right=df_images, on='image_id')
    unlabelled_image_df = df_images[~df_images['image_id'].isin(df_annotations['image_id'])]
    df = pd.concat([df, unlabelled_image_df], sort=True, ignore_index=True)

    Keys = namedtuple("Keys", ['ann_keys', 'img_keys', 'cat_keys'])
    keys = Keys(ann_keys=annotation_keys, img_keys=image_keys, cat_keys=category_keys)

    logging.info("Evaluating on {}".format(args.on))
    if args.on == 'images':
        df = eval_on(df, args, keys, 'image_id')
    elif args.on == 'annotations':
        df = eval_on(df, args, keys, 'annotation_id')

    images = []
    df_images = df[image_keys]
    if not df_images.empty:
        for record in df_images.itertuples():
            images.append(record_to_dict(record, 'image_id'))

    annotations = []

    df_annotations = df[annotation_keys]
    unlabelled_ids = set(unlabelled_image_df['image_id'])
    if not df_annotations.empty:
        for record in df_annotations.itertuples():
            annotation = record_to_dict(record, 'annotation_id')
            if annotation['image_id'] in unlabelled_ids:
                continue
            annotations.append(annotation)

    categories = []
    df_categories = df[category_keys]
    for category in data.get('categories', []):
        category['id'] = category.pop('category_id')
    hashed_categories = set(to_tuple([list(item) for item in sorted(entry.items())]) for entry in data.get('categories', []))
    if not df_categories.empty:
        for record in df_categories.itertuples():
            category = record_to_dict(record, 'category_id')
            tuple_category = to_tuple([list(item) for item in sorted(category.items())])
            if tuple_category in hashed_categories:
                categories.append(category)

    data['annotations'] = drop_duplicates(annotations)
    data['images'] = original_images if args.keep_images else drop_duplicates(images)

    if args.keep_categories:
        for category in data['categories']:
            category['id'] = category.pop('category_id')
    else:
        data['categories'] = drop_duplicates(categories)

    logging.info("Printing to stdout")
    json.dump(data, sys.stdout, indent=args.indent)
    logging.info("Done in {elapsed_time}s".format(elapsed_time=time.perf_counter() - tic))
    sys.exit(0)


def create_data_frame(data: dict) -> pd.DataFrame:
    df = pd.DataFrame(data)
    values = {}
    invalid_values = []
    for column_name in df:
        try:
            values[column_name] = df[column_name].mode()[0]
        except IndexError:
            invalid_values.append(column_name)
        except TypeError:
            invalid_values.append(column_name)
    return df


def to_tuple(entry_: list):
    return tuple(to_tuple(i) if isinstance(i, list) else i for i in entry_)


def drop_duplicates(list_: list):
    return [dict(item) for item in set(to_tuple([list(item) for item in sorted(entry.items())]) for entry in list_)]


def record_to_dict(record: namedtuple, re_id: str) -> dict:
    dict_ = record._asdict()
    dict_['id'] = dict_.pop(re_id)
    dict_.pop('Index')
    return dict_


def eval_on(df: pd.DataFrame, args: argparse.Namespace, keys: namedtuple, on_id: str) -> pd.DataFrame:
    ids = set()
    df_images = df[keys.img_keys].rename(index=str, columns={'image_id': 'id'})
    df_categories = df[keys.cat_keys].rename(index=str, columns={'category_id': 'id'})
    df_annotations = df[keys.ann_keys].rename(index=str, columns={'annotation_id': 'id'})

    try:
        exec(args.init)
    except TypeError:
        pass

    for a, i, c in zip(df_annotations.itertuples(), df_images.itertuples(), df_categories.itertuples()):
        idx = int(a.Index)
        if eval(args.expression):
            ids.add(df.iloc[idx][on_id])

    # Index later so that indexing into list doesn't go out of bounds as df shrinks
    df = df.loc[df[on_id].isin(ids)]
    return df


def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=_DESCRIPTION,
                                     formatter_class=argparse.RawDescriptionHelpFormatter, )
    parser.add_argument('on',
                        type=str,
                        choices={'images', 'annotations'},
                        help="How to search and select images and annotations. If on is 'image', then evaluate the "
                             "expression on a per image basis and for images that satisfy the expression, select all "
                             "associated annotations. If on is 'annotation', then evaluate the expression on a per "
                             "annotation basis and for annotations that satisfy the expression, select all associated "
                             "images.")
    parser.add_argument('expression', type=str, help="General expression to search for images.", )
    parser.add_argument('-i', '--init', type=str, help="General python code to run at the start of the script")
    parser.add_argument('-m', '--min', action='store_const', const=None, default=4, dest='indent',
                        help="Disable JSON pretty print.")
    parser.add_argument('--keep-categories', action='store_true',
                        help='Carry over all categories from original COCO JSON file.')
    parser.add_argument('--keep-images', action='store_true',
                        help='Carry over all images from original COCO JSON file.')
    parser.add_argument('-v', '--verbose', action='store_const', const=logging.INFO, help="More output to stderr.")
    return parser.parse_args()


if __name__ == '__main__':
    main(get_args())
