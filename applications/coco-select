#!/usr/bin/env python3
import argparse
import json
import os
import sys
from contextlib import redirect_stdout
from operator import itemgetter

from pycocotools.coco import COCO

DESCRIPTION = \
"""
Read COCO json file piped in from stdin and select images and ALL associated annotations that satisfy a given expression. 

Possible expressions that can be used are:
    img_id/image_id
    cat_id/category_id
    cat/category
    supcat/supercategory
    multiple cats/categories i.e. 'JD' in cats/categories and 'F' in cats/categories
    multiple supcats/supercategories i.e. 'JD' in supcats/supercategories or 'F' in supcats/supercategories

examples:
    cat coco.json | coco-select "img_id == 10".                                             Select all images where image_id is 10 (img_id is an alias for image_id)
    cat coco.json | coco-select "image_id == 5".                                            Select all images where image_id is 5
    
    cat coco.json | coco-select "cat_id == 2"                                               Select all images that have category_id 2 (cat_id is an alias for category_id)
    cat coco.json | coco-select "category_id == 3"                                          Select all images that have category_id 3
    
    cat coco.json | coco-select "cat == 'JD'"                                               Select all images that have category JD i.e. joint displacement (cat is an alias for category)
    cat coco.json | coco-select "category == 'RI'"                                          Select all images that have category RI i.e. root intrusion
    
    cat coco.json | coco-select "'JD' in cats and 'RI' in cats"                             Select all images that have joint displacement AND root intrusion as annotations
    cat coco.json | coco-select "'JD' in categories or 'F' in categories"                   Select all images that have either joint displacement OR root intrusion as annotations
    
    cat coco.json | coco-select "not 'C' in supcats and 'ED' in supcats"                    Select all images that do not have C i.e. cracks as a supercategory and have ED as a supercategory
    cat coco.json | coco-select "not 'JD' in supercategories or 'F' in supercategories"     Select all images that do not have joint displacement or have F i.e. fault as a supercategory
    
    cat coco.json | coco-select "img_id in img_ids"                                         Select all images
    
    cat coco.json | coco-select "cat == 'JD'" --keep-cats JD                                Select all images that have JD as an annotation and keep ONLY annotations with JD as a category
    cat coco.json | coco-select --keep-cats JD,RI,C                                         Select all images and keep only annotations that have JD, RI, or C as a category   
"""


def main():
    global ARGS
    ARGS = get_args()
    ARGS.expression = ARGS.expression.replace('-', '_')
    say("search expressions is [{}]".format(ARGS.expression))

    say("creating coco object")
    coco = load_coco(sys.stdin.read())

    try:
        all_cats = {cat['name'].replace('-', '_'): False for cat in coco.loadCats(coco.getCatIds()) if cat['name']}
    except KeyError as e:
        say("expected key [{}] in coco file".format(str(e)))
        all_cats = {}

    globals().update(all_cats)

    try:
        all_supcats = {cat['supercategory'].replace('-', '_'): False for cat in coco.loadCats(coco.getCatIds()) if
                       cat['supercategory']}
    except KeyError as e:
        say("expected key [{}] in coco file".format(str(e)))
        all_supcats = {}

    globals().update(all_supcats)

    try:
        all_captions = {item['caption']: False for item in coco.anns.values()}
    except KeyError as e:
        say("expected key [{}] in coco file".format(str(e)))
        all_captions = {}

    globals().update(all_captions)

    # Load all annotations
    anns = coco.loadAnns(coco.getAnnIds())

    # Sort all annotations by their image id, then the annotation id as an image can have multiple annotations
    anns.sort(key=itemgetter('image_id', 'id'))

    # Image ids to carry over from COCO dataset
    to_add_img_ids = set()

    global img_id, image_id
    global img_ids, image_ids
    global cat_ids, category_ids
    global cat_id, category_id
    global cats, categories
    global cat, category
    global supcats, supercategories
    global supcat, supercategory
    global caps, captions
    global cap, caption

    img_ids = image_ids = coco.getImgIds()
    for curr_img_id in coco.getImgIds():
        # Reinitialize image id for expression check
        img_id = image_id = None

        # Reinitialize category id for expression check
        cat_ids = category_ids = []
        cat_id = category_id = None

        # Reinitialize category for expression check
        globals().update(all_cats)
        cats = categories = []
        cat = category = None

        # Reinitialize super category for expression check
        globals().update(all_supcats)
        supcats = supercategories = []
        supcat = supercategory = None

        # Reinitialize captions for expression check
        globals().update(all_captions)
        caps = captions = []
        cap = caption = None

        # Check expression for image id i.e. image_id == 1
        img_id = image_id = curr_img_id

        to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for category_ids i.e. 2 in category_ids and 3 in category_ids
        try:
            cat_ids = category_ids = set(
                [ann['category_id'] for ann in coco.loadAnns(coco.getAnnIds(imgIds=curr_img_id))])
        except KeyError:
            pass

        to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for category_id ie. category_id == 2
        for category_id in cat_ids:
            cat_id = category_id
            to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for categories i.e. 'JD' and 'RI' OR 'JD' in categories and 'RI' in categories
        cats = categories = [cat['name'].replace('-', '_') for cat in coco.loadCats(cat_ids) if cat['name']]
        globals().update(dict.fromkeys(cats, True))
        to_add_img_ids.add(eval_expression(curr_img_id))

        # Check for single category i.e. category == 'JD'
        for category in categories:
            cat = category
            to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for supercategories
        supcats = supercategories = [cat['supercategory'].replace('-', '_') for cat in coco.loadCats(cat_ids) if
                                     cat['supercategory']]
        globals().update(dict.fromkeys(supcats, True))
        to_add_img_ids.add(eval_expression(curr_img_id))

        # Check for single supercategory
        for supercategory in supercategories:
            supcat = supercategory
            to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for captions
        try:
            caps = captions = [item['caption'] for item in coco.anns.values() if
                               item['image_id'] == curr_img_id and item['caption']]
            globals().update(dict.fromkeys(caps, True))
            to_add_img_ids.add(eval_expression(curr_img_id))

            for caption in captions:
                cap = caption
                to_add_img_ids.add(eval_expression(curr_img_id))
        except KeyError:
            pass

    to_add_ann_ids = coco.getAnnIds(imgIds=to_add_img_ids)
    to_add_img_ids = set()
    if ARGS.keep_cats:
        keep_cats = ARGS.keep_cats.split(',')
        tmp, to_add_ann_ids = to_add_ann_ids, []
        cat_id_2_cat = {cat['id']: cat['name'] for cat in coco.loadCats(coco.getCatIds())}
        for ann in coco.loadAnns(tmp):
            cat_id = ann['category_id']
            if cat_id_2_cat[cat_id] in keep_cats or str(cat_id) in keep_cats:
                to_add_ann_ids.append(ann['id'])
                to_add_img_ids.add(ann['image_id'])
    elif ARGS.keep_captions:
        keep_captions = ARGS.keep_captions.split(',')
        tmp, to_add_ann_ids = to_add_ann_ids, []
        for ann in coco.loadAnns(tmp):
            if ann['caption'] in keep_captions:
                to_add_ann_ids.append(ann['id'])
                to_add_img_ids.add(ann['image_id'])

    try:
        to_add_img_ids.remove(None)
    except KeyError as e:
        say("expected key [{}] in coco file".format(str(e)))
    imgs = coco.loadImgs(to_add_img_ids)

    coco.dataset['images'] = [] if imgs is None else imgs
    coco.dataset['annotations'] = coco.loadAnns(to_add_ann_ids)

    json.dump(coco.dataset, sys.stdout, indent=4)
    say("done")
    sys.exit()


def eval_expression(curr_img_id):
    try:
        if eval(ARGS.expression):
            return curr_img_id
    except NameError:
        pass


def load_coco(json_buffer: str) -> COCO:
    with redirect_stdout(Verbose):
        coco = COCO()
        coco.dataset = json.loads(json_buffer)
        coco.createIndex()
    return coco


class Verbose:
    @staticmethod
    def write(line: str):
        line = line.strip()
        if line:
            say(line)


def say(*args, verbose=False, **kwargs):
    if ARGS.verbose or verbose:
        print("{}:".format(os.path.basename(__file__)), *args, file=sys.stderr, **kwargs)


def die(*args, **kwargs):
    say(*args, verbose=True, **kwargs)
    sys.exit(1)


def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('expression', type=str, help="General expression to search for images. If no expression give, "
                                                     "defaults to search for all images to select all images and "
                                                     "their annotations", default="image_id in image_ids", nargs='?')
    parser.add_argument('-cats', '--keep-cats', type=str, help="Specify specific categories or category ids (comma "
                                                               "separated) to keep for each image otherwise all "
                                                               "associated image annotations will be carried over. If "
                                                               "an image does not contain that annotation, "
                                                               "it will not be select")
    parser.add_argument('-caps', '--keep-captions', type=str, help="Specify specific captions (comma separated to "
                                                                   "keep for each image otherwise all associated "
                                                                   "image annotations will be carried over. If an "
                                                                   "image does not contain that caption, it will not "
                                                                   "be selected")
    parser.add_argument('-v', '--verbose', action='store_true', help="More output to stderr")
    return parser.parse_args()


if __name__ == '__main__':
    main()
