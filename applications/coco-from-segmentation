#!/usr/bin/env python3
import json
import os
import sys
from argparse import ArgumentParser
from datetime import datetime

import numpy as np
from skimage import io, measure

# np.set_printoptions(threshold=sys.maxsize)
PADDING = 1


def main(command_line_args=None):
    if command_line_args.category_id == 'from-mask':
        raise NotImplementedError("the from-mask param has not yet been implemented")

    original_json = json.load(sys.stdin)
    with open(command_line_args.mask_file) as f:
        mask_json = json.load(f)

    coco_json = {
        'images':      original_json.get('images', []),
        'annotations': [],
        'categories':  original_json.get('categories', [])
        }
    output_annotations = coco_json['annotations']

    # TODO: pre-process both images list by sorting on id
    id_2_original = {entry['id']: entry for entry in original_json['images']}
    for mask_entry in mask_json['images']:
        curr_id = mask_entry['id']
        original_entry = id_2_original.get(curr_id, None)
        if original_entry is None:
            continue
        mask_img = load_input(mask_entry)
        original_img = np.array(mask_img)
        if command_line_args.fill_above_thresh:
            mask_img = 1.0*mask_img > command_line_args.threshold

        contours = measure.find_contours(mask_img, command_line_args.threshold, command_line_args.level)
        for contour in contours:
            contour -= PADDING
            approximated = measure.approximate_polygon(contour, command_line_args.polygon_tolerance)
            contour_flipped = np.flip(approximated, axis=1)
            segmentation = contour_flipped.ravel().tolist()
            seg_to_points = [segmentation[n:n + 2] for n in range(0, len(segmentation), 2)]
            area, score = get_area_and_score(original_img, approximated)
            output_annotations.append({"segmentation": [segmentation],
                                       "area":         area,
                                       "iscrowd":      0,
                                       "image_id":     original_entry['id'],
                                       "bbox":         bounding_box(seg_to_points),
                                       "score":        score,
                                       "category_id":  int(command_line_args.category_id),
                                       "id":           len(output_annotations)
                                       })

    json.dump(coco_json, sys.stdout, indent=4)
    sys.exit(0)


def load_input(mask_entry):
    width = int(mask_entry['width'])
    height = int(mask_entry['height'])
    img = np.zeros((width + PADDING * 2, height + PADDING * 2))
    _, ext = os.path.splitext(mask_entry['path'])
    if 'bin' in ext:
        img_buf = np.fromfile(mask_entry['path'], dtype=np.float32)
        img_buf = np.reshape(img_buf, (width, height))
    elif ext in {'png', 'jpg'}:
        img_buf = io.imread(mask_entry['path']) / 255.0
    else:
        print("{}: file type {} unsupported".format(os.path.basename(__file__), ext))
        sys.exit(1)
    img[PADDING: PADDING + height, PADDING: PADDING + width] = img_buf[:, :]
    return img


# def area_polygon(polygon):
#    x = [i[0] for i in polygon]
#    y = [i[1] for i in polygon]
#    return float(0.5 * np.abs(np.dot(x, np.roll(y, 1)) -
#                              np.dot(y, np.roll(x, 1))))


def get_area_and_score(image, poly):
    mask = measure.grid_points_in_poly((image.shape[0], image.shape[1]), poly)
    poly = np.flip(poly, axis=1)
    area = np.count_nonzero(mask)
    if area == 0:
        return 0, 0
    return area, np.sum((mask * image)) / area


def bounding_box(polygon, w=None, h=None):
    """Return the bounding box of a given polygon"""
    min_x, min_y = np.min(polygon, axis=0)
    max_x, max_y = np.max(polygon, axis=0)
    if w is not None and h is not None:
        min_x = max(0, min_x)
        min_y = max(0, min_y)
        max_x = min(w, max_x)
        max_y = min(h, max_y)
    return [min_x, min_y, max_x - min_x, max_y - min_y]


def parse_cli():
    parser = ArgumentParser(
        description="The utility takes in a mask coco file and applies the segementations to the original file provided in stdin")
    parser.add_argument('mask_file', type=str, help="Mask JSON File")
    parser.add_argument('-c', '--category-id', type=str,
                        help="the id of the category to set the mask can be an int or from-mask", required=True)
    parser.add_argument('-t', '--threshold', '--thresh', type=float, default=0.0,
                        help="The number to threshold the image by, default: %(default)s")
    parser.add_argument('-b', '--fill-above-thresh', '--fill_above',  action='store_true' ,
                        help="this argument will fill the mask with 1 values if the pixel is above the threshold")
    parser.add_argument('--polygon-tolerance', '--tolerance', type=float, default=0.0,
                        help="threshold tolerance for polygon precision (see skimage.metrics.approximate_polygon(), default: %(default)s")
    parser.add_argument('--level', help="Passed to skimage.measure.find_contours, default: %(default)s", type=str, default='low')
    return parser.parse_args()


if __name__ == '__main__':
    main(command_line_args=parse_cli())
