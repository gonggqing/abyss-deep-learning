#!/usr/bin/env python3
from __future__ import print_function
import argparse
import os
import sys
import matplotlib.pyplot as plt
import numpy as np
from skimage.color import label2rgb
from skimage.io import imread
from skimage.measure import label
from skimage.transform import rescale
from abyss_deep_learning.coco_classes import CocoDataset


class SkipPairException(Exception):
    pass


def populate_coco(file_path, image_size, coco, boundaries, masks, categories, image_id, args):
    url = 'file://' + file_path
    path = os.path.realpath(file_path)

    image_id = coco.add_image(image_size, os.path.basename(
        file_path), url, force_id=image_id, path=path)
    for key, category in categories.items():
        mask = masks[key]
        # boundary = boundaries[key]
        if category <= 0:
            continue
        category_id = coco.add_category(
            args.class_names[category], id_number=int(category))
        # coco.add_annotation(image_id, category_id, mask)
        coco.add_annotation(image_id, category_id, np.squeeze(mask))
        # coco.add_annotation(image_id, category_id, boundary.reshape(-1).tolist())


def save_annotations(file_path, image_size, boundaries, masks, categories, image_id, args, coco=None, fcis=None):
    populate_coco(file_path, image_size, coco, boundaries,
                  masks, categories, image_id, args)


def decode_rgb_labels(encoded_image):
    return np.bitwise_or(
        np.bitwise_or(
            encoded_image[:, :, 0].astype(np.uint32),
            encoded_image[:, :, 1].astype(np.uint32) << 8
        ),
        encoded_image[:, :, 2].astype(np.uint32) << 16
    )


def process_pair(image_path, annotation_path, args):
    rgb = imread(image_path)
    if args.rescale:
        rgb = rescale(rgb, args.rescale)
    image_size = rgb.shape[0:2]  # [1::-1]
    labels_image = imread(annotation_path)
    if len(labels_image.shape) == 2:
        # Normal input, flat image coded by class number
        labels_image = labels_image[..., np.newaxis]
    else:
        # js-segmentation-annotator output, RGB encoded
        labels_image = decode_rgb_labels(labels_image[:, :, 0:3])
    unique_labels = np.unique(labels_image)
    if args.no_empty and len(unique_labels) <= 1:
        raise SkipPairException()
    if args.verbose:
        print("unique labels", file=sys.stderr)
        print(unique_labels, file=sys.stderr)
    categories, masks, boundaries = {}, {}, {}

    for class_idx in unique_labels:  # Category
        if class_idx == args.background:
            continue
        class_mask = labels_image == class_idx
        instances, num_instances = label(
            class_mask, background=args.background, return_num=True, connectivity=2)
        if args.verbose:
            print("Instances: ", num_instances,
                  np.unique(instances), file=sys.stderr)
        if args.single_instance:
            categories[0] = args.label
            masks[0] = class_mask
        else:
            for instance_idx in range(1, num_instances + 1):  # Instances
                instance_mask = instances == instance_idx
                # boundaries[class_idx] = np.fliplr(np.argwhere(find_boundaries(class_mask, mode='inner')))
                categories[instance_idx] = args.label
                masks[instance_idx] = instance_mask
    if args.display:
        print("# TODO this is showing only the last class_mask mask??", file=sys.stderr)
        image_masked = rgb.copy()
        image_masked[np.logical_not(class_mask), :] = 0
        plt.figure()
        plt.subplot(3, 1, 1)
        plt.imshow(rgb)
        plt.subplot(3, 1, 2)
        plt.imshow(labels_image)
        plt.subplot(3, 1, 3)
        plt.imshow(label2rgb(labels_image, rgb))
        plt.show()
    return (boundaries, masks, categories, image_size)


def get_args():
    '''Get args from the command line args'''
    parser = argparse.ArgumentParser(
        description="Create lists for convert_annoset")
    parser.add_argument(
        "image_dir", help="The directory which contains the images.")
    parser.add_argument(
        "label_dir", help="The directory which contains the annotations.")
    parser.add_argument("coco", help="Output path for coco file.")
    parser.add_argument(
        "class_names", help="csv-delimited list of class names in order starting from 0")
    parser.add_argument("--background", type=int,
                        help="Background value for label image", default=0)
    # parser.add_argument("--clear-border", action='store_true', default=False)
    parser.add_argument("--label", default=1,
                        help='The label to write (single class only supported)')
    parser.add_argument("--single-instance", action='store_true')
    parser.add_argument("--display", action='store_true')
    parser.add_argument("--verbose", action='store_true')
    parser.add_argument("--no-empty", action='store_true')
    parser.add_argument("--rescale", action='store', default=None)
    parser.add_argument(
        "--ext", help="The file extension to search for (default 'png')", default='png')
    args = parser.parse_args()

    args.class_names = {i: name for i,
                        name in enumerate(args.class_names.split(','))}
    if len(args.class_names) < 2:
        raise Exception(
            "Need at least 2 class names (e.g.: background,crop,weed)")
    return args


def main(args):
    coco_data = CocoDataset(is_pretty=False)
    for image_id, filename in enumerate(os.listdir(args.image_dir)):
        if filename.lower().endswith('.' + args.ext):
            file_path = os.path.join(args.image_dir, filename)
            if args.verbose:
                print(file_path, file=sys.stderr)
            annotation_path = os.path.join(args.label_dir, filename)
            if not os.path.exists(annotation_path):
                continue
            try:
                (boundaries, masks, categories, image_size) = process_pair(
                    file_path, annotation_path, args)
                save_annotations(file_path, image_size, boundaries,
                                 masks, categories, image_id, args, coco=coco_data)
            except SkipPairException:
                print("Skipped empty label: {:s}".format(
                    file_path), file=sys.stderr)
    with open(args.coco, 'w') as file_handle:
        file_handle.write(str(coco_data))


if __name__ == '__main__':
    main(get_args())
