#!/usr/bin/env python3
import argparse
import json
import logging
import sys
from itertools import groupby
from abyss_deep_learning.utils import MyCOCO

__author__ = 'Kent Hu, Jamie McColl, Toby Dunne'
__maintainer__ = 'Kent Hu'

DESCRIPTION = """
Read coco.json file(s) defined on command line
merge together 'images', 'annotations', 'categories' array.

Merges images and categories by id.
If there is a conflict:
 * if two images have the same id, and different paths, the second image will be renumbered and a warning produced.
    all annotations linked to the renumbered image will be updated to point to the new image_id
 * if two categories have the same id, and different names, the second category will be renumbered and a warning produced.
    all annotations linked to the renumbered category will be updated to point to the new category_id
    
Duplicate entries in the 'annotations' array will be removed 
    i.e. annotations with same image_id, category_id, bbox and segmentation)
Annotations id's in subsequent merged files will be numbered sequentially.

i.e. if dataset has two annotations ->
    first_ann = {                           |   second_ann = {
                  "id": 1,                  |                 "id": 2,
                  "category_id": 1,         |                 "category_id": 1,
                  "bbox": [0,0,0,0],        |                 "bbox": [0,0,0,0],
                  "segmentation" [ 0,0,0,0] |                 "segmentation" [ 0,0,0,0]
                }                           |                }
                
The second annotation will be removed as it has duplicate category id and bbox with the first annotation

Output merged coco json contents in stdout.

examples:
    coco-merge labelled/abc/coco.json labelled/def/coco.json
    
    cat labelled/abc/coco.json | coco-merge - labelled/def/coco.json
    
    --append-categories:
        Consider two JSONs - a.json has two categories with ids 0 and 100, b.json has six categories with ids from 0 to 5.
        
        coco-merge a.json b.json --append-categories
        
            The resulting JSON will have category ids 0, 100, 101, 102, 103, 104, 105, with 0 and 100 matching the
            categories found in a.json.
        
        Switching the order:
        coco-merge b.json a.json --append-categories
        
            The resulting JSON will have category ids 0, 1, 2, 3, 4, 5, 6, 106, with 0 to 5 matching the categories
            found in b.json.
"""


def any_lambda(iterable, function):
  return any(function(i) for i in iterable)


def max_or_zero(i):
    return max(i) if len(i) > 0 else 0


def merge(args, dest_coco, source_coco):

    max_image_id = max(max_or_zero(dest_coco.getImgIds()), max_or_zero(source_coco.getImgIds()))

    dest_max_category_id = max_or_zero(dest_coco.getCatIds())
    max_category_id = max(dest_max_category_id, max_or_zero(source_coco.getCatIds()))

    # Merge categories
    curr_cat_map = {el['id']: el for el in dest_coco.categories}

    for category in source_coco.categories:
        existing = curr_cat_map.get(category['id'], None)
        if args.append_categories:
            # append all categories, no merge
            existing_category_id = existing['id']
            category_id = dest_max_category_id + existing_category_id + 1
            for ann in filter(lambda x: x['category_id'] == existing_category_id, source_coco.annotations):
                ann['category_id'] = category_id
            category['id'] = category_id
            logging.info("Assigning new category id {} -> {}".format(existing_category_id, category_id))
        elif existing is not None:
            if existing['name'] != category['name']:
                # duplicate category id - same id, different name
                max_category_id += 1
                existing_category_id = existing['id']
                for ann in filter(lambda x: x['category_id'] == existing_category_id, source_coco.annotations):
                    ann['category_id'] = max_category_id
                category['id'] = max_category_id
                if args.merge_categories:
                    logging.info("Assigning new category id {} -> {}".format(existing_category_id, max_category_id))
                else:
                    logging.error("Category conflict ID: {} '{}' != '{}'. "
                                  "Specify --append-categories or --merge-categories ".format(category['id'],
                                                                                              category['name'],
                                                                                              existing['name']))
                    exit(-1)
            else:
                # same category_id, same name - skip second copy
                continue
        dest_coco.categories.append(category)

    # merge images
    curr_img_map = {el['id']: el for el in dest_coco.images}

    for image in source_coco.images:
        existing = curr_img_map.get(image['id'], None)
        if existing is not None:
            if existing['path'] != image['path']:
                # duplicate image id - same id, different path
                max_image_id += 1
                reassign_image_id = existing['id']
                for ann in filter(lambda x: x['image_id'] == reassign_image_id, source_coco.annotations):
                    ann['image_id'] = max_image_id
                image['id'] = max_image_id
                logging.warning("Assigning new image id {} -> {}".format(reassign_image_id, max_image_id))
            else:
                # same image_id, same path - skip second copy
                continue
        dest_coco.images.append(image)

    dest_annotations_sorted = sorted(dest_coco.annotations, key=lambda x: x['image_id'])
    dest_annotations_dict = dict([(key, group) for key, group in
                                  groupby(dest_annotations_sorted, lambda x: x['image_id'])])

    max_ann_id = max_or_zero(dest_coco.getAnnIds())
    source_annotations_sorted = sorted(source_coco.annotations, key=lambda x: x['image_id'])
    for key, group in groupby(source_annotations_sorted, lambda x: x['image_id']):
        dest_group = dest_annotations_dict.get(key, None)
        if dest_group is None:
            for ann in group:
                max_ann_id += 1
                ann['id'] = max_ann_id
                dest_coco.annotations.append(ann)
        else:
            for source_ann in group:
                if not any_lambda(dest_group, lambda x: x['image_id'] == source_ann['image_id']
                                          and x['category_id'] == source_ann['category_id']
                                          and x['bbox'] == source_ann['bbox']
                                          and x['segmentation'] == source_ann['segmentation']):
                    max_ann_id += 1
                    source_ann['id'] = max_ann_id
                    dest_coco.annotations.append(source_ann)

    dest_coco.createIndex()
    return dest_coco


def main(args):
    logging.basicConfig(
        format='%(filename)s: %(asctime)s.%(msecs)d: %(levelname)s: %(lineno)d: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        level=args.loglevel,
    )
    coco_list = []
    for file_arg in args.files:
        if file_arg == '-':
            file = sys.stdin
        else:
            file = file_arg
        try:
            curr_coco = MyCOCO(file)
            coco_list.append(curr_coco)
        except json.decoder.JSONDecodeError:
            logging.error("File is not valid JSON: {}".format(file))
            sys.exit(-1)
        except Exception as ex:
            logging.error("Error loading: {} {}".format(file, ex))
            sys.exit(-1)

    if len(coco_list) == 1:
        coco_out = coco_list[0]
    else:
        coco_out = coco_list[0]
        for i in range(1, len(coco_list)):
            coco_out = merge(args, coco_out, coco_list[i])

    json.dump(coco_out.dataset, sys.stdout, indent=args.indent)
    return 0


def get_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument(
        'files',
        nargs='*',
        help="JSON files to merge together into one json (use - to read one file from stdin)",
    )
    parser.add_argument(
        '--append-categories',
        action='store_true',
        help='Assign category IDs in by appending, such that the ranges of IDs from different JSONs do not overlap\n'
             'e.g.\n'
             '[{ "id":0: "name": "A"}, { "id":1: "name": "B"}]\n'   
             '[{ "id":0: "name": "A"}, { "id":1: "name": "B"}]\n'
             ' vvv\n'
             '[{ "id":0: "name": "A"}, { "id":1: "name": "B"}, { "id":2: "name": "A"}, { "id":3: "name": "B"},]'

    )
    parser.add_argument(
        '--merge-categories',
        action='store_true',
        help='Assign category IDs by merging (a warning is produced on re-assignment),\n'
             'e.g.\n'
             '[{ "id":0: "name": "A"}, { "id":1: "name": "B"}]\n'
             '[{ "id":0: "name": "X"}, { "id":1: "name": "B"}]\n'
             ' vvv\n'
             '[{ "id":0: "name": "A"}, { "id":1: "name": "B"}, { "id":2: "name": "X"}]'
    )
    parser.add_argument(
        '--minified',
        action='store_const',
        const=None,
        default=4,
        dest='indent',
        help="disable JSON pretty print",
    )
    logging_group = parser.add_mutually_exclusive_group()
    logging_group.add_argument(
        '-v', '--verbose',
        action='store_const',
        const=logging.INFO,
        dest='loglevel',
        help="Verbose output to stderr",
    )
    logging_group.add_argument(
        '-d', '--debug',
        action='store_const',
        const=logging.DEBUG,
        dest='loglevel',
        help="Debug output to stderr",
    )
    return parser.parse_args()


if __name__ == '__main__':
    sys.exit(main(get_args()))
