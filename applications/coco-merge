#!/usr/bin/env python3
import argparse
import json
import os
import sys
from collections import defaultdict
from operator import itemgetter

DESCRIPTION = \
"""
Read coco.json file(s) defined on command line or piped in from another coco utility.

Output merged coco json contents in stdout.

examples:
    coco-merge labelled/abc/coco.json labelled/def/coco.json
    find . -name coco.json | coco-merge
"""


def main():
    global ARGS
    ARGS = get_args()

    if not ARGS.json_files:
        ARGS.json_files = (sys.stdin.read().split("\n"))
        del ARGS.json_files[-1]

    images = []  # Merged images
    annotations = []  # Merged annotations
    licenses = []  # Merged licenses
    img_count = defaultdict(int)  # Count occurrences of an image across all json files to be merged
    old_id_2_path = {}  # Mapping of old image id to the unique image path, many to one relationship
    path_2_new_id = {}  # Mapping of unique image path to new id, one to one relationship

    for json_file_path_or_buffer in ARGS.json_files:
        say("loading dataset")
        old_ds = load_dataset(json_file_path_or_buffer)
        if not old_ds:
            continue

        say("merging dataset")
        for image in old_ds['images']:
            if 'path' not in image:
                continue

            img_file_name, img_ext = os.path.splitext(os.path.basename(image['path']))
            img_count[img_file_name] += 1

            old_id = image['id']
            old_id_2_path[old_id] = img_file_name

            if img_count[img_file_name] == 1:
                new_id = len(images)
                image['id'] = new_id
                images.append(image)
                path_2_new_id[img_file_name] = new_id

        for ann in old_ds['annotations']:
            old_id = ann['image_id']
            img_file_name = old_id_2_path[old_id]
            new_id = path_2_new_id[img_file_name]
            ann['image_id'] = new_id
            del ann['id']
            annotations.append(ann)

        try:
            for license in old_ds['licenses']:
                licenses.append(license)
        except KeyError:
            pass

    # Remove duplicate annotations
    annotations = [dict(item) for item in set(tuple(ann.items()) for ann in annotations)]

    # Sort annotations by image id
    annotations.sort(key=itemgetter('image_id'))

    # Assign annotation ids
    tmp_annotations = annotations.copy()
    annotations.clear()

    for idx, ann in enumerate(tmp_annotations):
        ann['id'] = idx + 1
        annotations.append(ann)

    if not ARGS.file_name:
        ARGS.file_name = ARGS.json_files[0]

    dataset = load_dataset(ARGS.file_name)
    merged_data_set = {
        'info': dataset['info'] if dataset and 'info' in dataset else None,
        'images': images,
        'annotations': annotations,
        'licenses': licenses,
    }

    json.dump(merged_data_set, sys.stdout, indent=4)
    say("done")
    sys.exit()


def say(*arg, **kwargs):
    if ARGS.verbose:
        print("{}:".format(os.path.basename(__file__)), *arg, file=sys.stderr, **kwargs)


def load_dataset(json_file_path):
    try:
        with open(json_file_path, 'r') as file_handle:
            in_dataset = json.load(file_handle)
        return in_dataset
    except IOError:
        pass


def get_args():
    """Get args from the command line args"""
    parser = argparse.ArgumentParser(description=DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('json_files', nargs='*', type=str, help="JSON files to merge together into one json")
    parser.add_argument('-f', '--file_name', nargs=1, type=str, help="COCO json file to copy info to new dataset, "
                                                                     "default is the first json file")
    parser.add_argument('-v', '--verbose', action='store_true', help="More output to stderr")
    return parser.parse_args()


if __name__ == '__main__':
    main()
