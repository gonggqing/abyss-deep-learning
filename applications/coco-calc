#!/usr/bin/env python3
import argparse
import copy
import itertools
import json
import logging
import os
import sys
from contextlib import redirect_stdout
from operator import itemgetter

from pycocotools.coco import COCO

_PARSER_DESCRIPTION = """
Operations apply to all images in the dataset. For more information on each operation, append -h to the subcommand
"""

_DESCRIPTION = """
Read COCO json file piped in from stdin or a list of COCO json files and apply image manipulation and 
processing. Output new COCO json file with relevant changes to the data and if output images is specified, 
output an image directory in the current working directory with all modified images.

RLE not currently supported for segmentation resizing
tile action is currently dummy action for demonstration purposes

examples:
    remap
        cat pf.json | coco-calc remap "{1:1,2:1,3:1,4:1}" --categories '{ "id": 1, "name": "PF" }'
        cat pf.json | coco-calc remap "{'PF-G':'PF','PF-L':'PF','PF-M':'PF','PF-H':'PF'}"

    resize
        cat coco.json | coco-calc resize --factor 0.3
        cat coco.json | coco-calc --verbose resize --size 480,640

    tile
        cat coco.json | coco-calc --apply-to-images tile --tiles 4,5
"""

_REMAP_DESCRIPTION = """
Remap categories and/or category id to categories and/or category id.

A JSON string can be passed in or another COCO JSON file that contains categories can be passed in.

If a COCO JSON is passed, as many categories will be matched with the existing COCO JSON and new ids will be assigned 
from category names that are matched. It is possible, consequently for duplicate ids to occur depending on how the 
categories are formatted in either COCO file. 

5 use cases:
    old id to new id
        "{1:1,2:1,3:1,4:1}" collapses all category ids to one id
        "{1:0,2:1,3:2,4:3}" change starting index of all categories
    
    old id to new category
        "{1: 'PF', 2:'PF', 3:'PF', 4:'PF'}"                         collapses all categories to a single category
        "{1: 'PF-L'}"                                               combine category id 1 with PF-L category
    
    old category to new id
        "{'PF-G': 1,'PF-L': 2,'PF-M': 3,'PF-H': 4}"                 change category ordering
    
    old category to new category
        "{'PF-G': 'PF', 'PF-L':'PF', 'PF-M':'PF', 'PF-H':'PF'}"     collapses all categories to a single category
        "{'PF-G': 'PF-L'}"                                          combine PF-G with PF-L

    a COCO JSON file can also be passed as an argument to [mapping] where the categories list will be used in place 
    as the mapping.

examples
    cat pf.json | coco-calc remap "{1:1,2:1,3:1,4:1}"
    cat pf.json | coco-calc remap "{'PF-G':'PF','PF-L':'PF','PF-M':'PF','PF-H':'PF'}" --categories "[{'name':'PF',
    'id':5}]" 
    cat predictions.json | coco-calc remap validation.json
"""

_RESIZE_DESCRIPTION = """
Resize images in a given coco json file. Image dimensions can be specified by [width],[height] or by a 
scaling factor to enlarge or reduce. Specify -o/--output-images with an output image directory which 
will write the new directory, if not created, in the current directory with the new images.

examples
    cat coco.json | coco-calc resize --factor 0.3
    cat coco.json | coco-calc --verbose resize --size 480,640
"""

_CROP_DESCRIPTION = """
Crop images and labels; currently supports only cropping images

example
    cat crop.json | applications/coco-calc -v crop --size 513,513 --point --apply-to-images --fit
    
"""

_REPATH_DESCRIPTION = """
Read coco file from stdin and re-path all images.

Output coco json contents in stdout.

examples:
    cat coco.json | coco-calc repath images
    cat coco.json | coco-calc repath /mnt/rhino/processed/industry-data/anadarko/images
"""

_ASSIGN_NEW_IMAGE_IDS_DESCRIPTION = """
Read in COCO file from stdin and reassigned the image ids of incoming COCO file based on the image ids from
the command line COCO. The new ids are matched by the file_name of either COCO files

Input COCO file from stdin is output to stdout.

If no COCO file is passed in, the input COCO file can have new image ids assigned based on the existing ordering or
the input COCO file can be sorted based on a field in 'images' and then have new ids assigned based on the ordering

examples:
    cat input.json | coco-calc assign-new-image-id coco coco.json --key file_name # Match by key and assign new ids to input COCO from command line COCO 
    cat input.json | coco-calc assign-new-image-id sort --key file_name # Sort the images by a key then assign new ids, if no key, assign image ids based on existing ordering
"""


def main(args):
    # Setup logging of default warnings and verbose print
    logging.basicConfig(
        level=args.verbose,
        datefmt='%Y-%m-%d %H:%M:%S',
        format='%(filename)s: %(asctime)s.%(msecs)d: %(levelname)s: %(message)s',
    )
    logging.info("-v/--verbose enabled.")
    coco = args.func(load_coco(sys.stdin.read()), args)
    if coco.dataset is None:
        logging.warning("Output coco is empty.")
    else:
        json.dump(coco.dataset, sys.stdout, indent=args.indent)
    sys.exit(0)


def crop(coco: COCO, args) -> COCO:
    from abyss_deep_learning.utils import imread
    logging.info("crop operation selected")
    if args.keep_partial:
        logging.error('coco-calc crop --keep-partial: TODO')
        sys.exit(1)
    width, height = map(int, args.size.split(','))
    if args.apply_to_images:
        os.makedirs(os.path.join(os.getcwd(), args.image_output_dir), exist_ok=True)
    output_images = []
    output_annotations = []
    for image_data in coco.loadImgs(coco.getImgIds()):
        path = None
        basenames = set()
        if os.path.isfile(image_data['path']):
            path = image_data['path']
        elif os.path.isfile(os.path.abspath(image_data['path'])):
            path = image_data['path']
        else:
            logging.error("File not found: [{}]".format(image_data['path']))
            sys.exit(1)
        basename = os.path.basename(image_data['path'])
        stubname = os.path.join(os.getcwd(), args.image_output_dir, '.'.join(basename.split('.')[:-1]))
        do_crop = False
        if args.point:
            annotations = coco.loadAnns(coco.getAnnIds(image_data['id']))
            for a in annotations:
                if a['annotation_type'] == 'point':
                    do_crop = True
                    break
        if not do_crop:
            continue
        image = imread(image_data['path'])
        if args.point:
            annotations = coco.loadAnns(coco.getAnnIds(image_data['id']))
            for a in annotations:
                if a['annotation_type'] != 'point':
                    continue  # todo: point selection quick and dirty for now; implement better usage semantics
                x = int(a['bbox'][0]) - int(width / 2)
                y = int(a['bbox'][1]) - int(height / 2)
                if args.fit:
                    x = min(max(x, 0), image_data['width'] - width)
                    y = min(max(y, 0), image_data['height'] - height)
                elif x < 0 or y < 0 or x >= image_data['width'] - width or y >= image_data['height'] - height:
                    logging.warning("coco-calc: crop: discarded annotation with patch beyond image dimensions (or please use --fit): annotation id:", a['id'], "image:", image_data['path'])
                    continue
                cropped = image[y: y + height, x: x + width]
                path = stubname + '.' + str(a['id']) + '.png'
                i = copy.deepcopy(image_data)
                i['file_name'] = os.path.basename(path)
                i['path'] = path
                i['id'] = len(output_images)
                i['height'] = height
                i['width'] = width
                output_images.append(i)
                for a in annotations:
                    if a['annotation_type'] == 'point':
                        continue  # todo: better semantics
                    b = copy.deepcopy(a)
                    if 'bbox' in a:
                        x0 = a['bbox'][0] - x
                        y0 = a['bbox'][1] - y
                        x1 = x0 + a['bbox'][2]
                        y1 = y0 + a['bbox'][3]
                        if x0 < 0 or y0 < 0 or x1 > (width - 1) or y1 > (height - 1):
                            continue
                        b['bbox'] = [x0, y0, a['bbox'][2], a['bbox'][3]]
                    if 'segmentation' in a:
                        if isinstance(a['segmentation'], dict):
                            print('coco-calc crop: RLE: todo; discarded', file=sys.stderr);
                            continue
                        if isinstance(a['segmentation'], list):
                            fits_into_crop = True
                            u = []
                            for s in a['segmentation']:
                                t = []
                                for xs, ys in grouper(s, 2):
                                    xs -= x
                                    ys -= y
                                    if xs < 0 or ys < 0 or xs > (width - 1) or ys > (height - 1):
                                        fits_into_crop = False
                                        break
                                    t += [xs, ys]
                                if not fits_into_crop:
                                    break
                                u.append(t)
                            if not fits_into_crop:
                                continue
                            b['segmentation'] = u
                    b['id'] = len(output_annotations)
                    b['image_id'] = i['id']
                    output_annotations.append(b)
                if args.apply_to_images:
                    from PIL import Image
                    Image.fromarray(cropped).save(path)
    coco.dataset['images'] = output_images
    coco.dataset['annotations'] = output_annotations
    return coco


def remap(coco: COCO, args) -> COCO:
    # literal_eval allows usage of either single quote (') or double quote(") to interpret a json string
    from ast import literal_eval
    logging.info("remap operation selected")
    if os.path.isfile(args.mapping):
        with open(args.mapping) as f:
            mapping = {category['name']: category['id'] for category in json.load(f)['categories']}
    else:
        mapping = literal_eval(args.mapping)

    source_categories = coco.loadCats(ids=coco.getCatIds())
    if not source_categories:
        return coco
    for category in source_categories:
        if not (category['id'] in mapping or category['name'] in mapping):
            mapping[category['name']] = category['name']

    output_categories = copy.deepcopy(coco.loadCats(ids=coco.getCatIds()))
    for category in output_categories:
        if category['name'] in mapping.keys():
            category_id = mapping[category['name']]
            if isinstance(category_id, int):
                category['id'] = category_id

    target_categories = source_categories
    if args.target_categories:
        args.target_categories = literal_eval(args.target_categories)
        if args.keep_source_categories:
            source_category_ids = set([category['id'] for category in output_categories])
            target_category_ids = set([category['id'] for category in args.target_categories])
            for idx in target_category_ids:
                if idx in source_category_ids:
                    logging.error("Duplicate id {} found between source and target categories".format(idx))
                    logging.error("Taken ids are {}".format(", ".join((str(i) for i in source_category_ids))))
                    sys.exit(1)
        target_categories = args.target_categories

    new_name_2_id = {category['name']: category['id'] for category in target_categories}
    source_category_names = [category['name'] for category in source_categories]
    target_category_names = [category['name'] for category in target_categories]
    annotations = []
    if len(coco.dataset['annotations']) > 0:
        added_annotation_ids = set()

        for old, new in mapping.items():
            if isinstance(old, str) and old not in source_category_names:
                logging.error("Cannot find source key {} in category names {}".format(old, source_category_names))
                sys.exit(1)

            if isinstance(new, str) and new not in target_category_names:
                logging.error("cannot find target key {} in category names {}".format(new, target_category_names))
                sys.exit(1)

            elif isinstance(old, int) and isinstance(new, int):
                for ann in coco.loadAnns(ids=coco.getAnnIds(catIds=old)):
                    ann_copy = copy.deepcopy(ann)
                    ann_copy['category_id'] = new
                    annotations.append(ann_copy)
                    added_annotation_ids.add(ann_copy['id'])
                category = coco.loadCats(ids=coco.getCatIds(catIds=old)).pop()
                category['id'] = new

            elif isinstance(old, int) and isinstance(new, str):
                if new in new_name_2_id.keys():
                    for ann in coco.loadAnns(ids=coco.getAnnIds(catIds=old)):
                        ann_copy = copy.deepcopy(ann)
                        ann_copy['category_id'] = new_name_2_id[new]
                        annotations.append(ann_copy)
                        added_annotation_ids.add(ann_copy['id'])

            elif isinstance(old, str) and isinstance(new, int):
                for ann in coco.loadAnns(ids=coco.getAnnIds(catIds=coco.getCatIds(catNms=old))):
                    ann_copy = copy.deepcopy(ann)
                    ann_copy['category_id'] = new
                    annotations.append(ann_copy)
                    added_annotation_ids.add(ann_copy['id'])
                category = coco.loadCats(ids=coco.getCatIds(catNms=old)).pop()
                category['id'] = new

            elif isinstance(old, str) and isinstance(new, str):
                if new in new_name_2_id.keys():
                    for ann in coco.loadAnns(ids=coco.getAnnIds(catIds=coco.getCatIds(catNms=old))):
                        ann_copy = copy.deepcopy(ann)
                        ann_copy['category_id'] = new_name_2_id[new]
                        annotations.append(ann_copy)
                        added_annotation_ids.add(ann_copy['id'])

        to_add_annotation_ids = set(coco.getAnnIds()) - added_annotation_ids
        annotations.extend(coco.loadAnns(ids=to_add_annotation_ids))

    coco.dataset['annotations'] = annotations

    categories = target_categories
    if args.keep_source_categories:
        categories.extend(source_categories)

    coco.dataset['categories'] = sorted(drop_duplicates(categories), key=itemgetter('id'))
    category_ids = coco.getCatIds()
    if len(set(category_ids)) != len(category_ids):
        logging.warning('There are duplicate category ids in the coco dataset.')

    return coco


def resize(coco: COCO, args) -> COCO:
    """

    Args:
        coco: COCO file read from stdin
        args: arguments passed from argparse

    Returns: COCO file with correct values for bbox, area, and segmentation based on either args.scale or args.factor

    """
    logging.info("resize operation selected")
    if args.apply_to_images:
        from abyss_deep_learning.utils import imread
        from PIL import Image

        os.makedirs(os.path.join(os.getcwd(), args.image_output_dir), exist_ok=True)

    paths = set()
    for image_entry in coco.dataset['images']:
        if 'height' not in image_entry:
            logging.warning("Cannot find height value")
            logging.warning("Skipping image with id {}".format(image_entry['id']))
            continue

        if 'width' not in image_entry:
            logging.warning("Cannot find width value")
            logging.warning("Skipping image with id {}".format(image_entry['id']))
            continue

        if args.factor is None:
            dims = args.size.split(',')
            h_scale = float(dims[0]) / image_entry['width']
            v_scale = float(dims[1]) / image_entry['height']
        else:
            h_scale = v_scale = args.factor

        image_entry['height'] = round(image_entry['height'] * v_scale, None)
        image_entry['width'] = round(image_entry['width'] * h_scale, None)

        if args.apply_to_images:
            if os.path.isfile(image_entry['path']):
                new_path = os.path.join(os.getcwd(), args.image_output_dir, os.path.basename(image_entry['path']))
                if new_path in paths:
                    logging.error('coco-calc: resize: expected unique image filenames, got duplicated "{}"'.format(new_path))
                    sys.exit(1)
                paths.add(new_path)
                image_entry['path'] = new_path
                resized_img = imread(image_entry['path'], output_size=(image_entry['width'], image_entry['height']))
                logging.info("Saving image to {}".format(new_path))
                Image.fromarray(resized_img).save(new_path)
            else:
                logging.warning("Cannot find path to image [{}]".format(image_entry['path']))

        # Rescaling bbox and segmentation values
        # format is [x, y, width, height]
        # Rescaled area value i.e. new_width * new_height
        for ann in coco.loadAnns(coco.getAnnIds(imgIds=image_entry['id'])):
            x = round(ann['bbox'][0] * h_scale, args.digits)
            y = round(ann['bbox'][1] * v_scale, args.digits)
            width = round(ann['bbox'][2] * h_scale, args.digits)
            height = round(ann['bbox'][3] * v_scale, args.digits)
            ann['bbox'] = [x, y, width, height]
            ann['area'] = width * height

            if 'segmentation' in ann:
                tmp = ann['segmentation']
                if type(tmp) is list:
                    segmentation = []
                    for segment in tmp:
                        new_segment = [(round(x * h_scale, args.digits), round(y * v_scale, args.digits)) for x, y in grouper(segment, 2)]
                        # Flatten the list of tuples
                        new_segment = list(itertools.chain(*new_segment))
                        segmentation.append(new_segment)
                    ann['segmentation'] = segmentation
                elif type(tmp) is dict:
                    logging.warning("RLE is not yet supported")
                else:
                    logging.warning("Unknown data type [{}]".format(type(tmp)))
            else:
                logging.warning("Annotation with id", ann['id'], "does not have 'segmentation'. Skipping annotation")

    return coco


def repath(coco: COCO, args: argparse.Namespace) -> COCO:
    """

    Args:
        coco: COCO file read from stdin
        args: arguments passed from argparse

    Returns: COCO file with image paths that have been prepended with args.path

    """
    logging.info("repath operation selected")
    for image in coco.dataset['images']:
        try:
            image['path'] = os.path.join(args.path, os.path.basename(image['path']))
        except KeyError:
            logging.warning("Unable to find 'path' key for image {}".format(image))
            try:
                image['path'] = os.path.join(args.path, os.path.basename(image['file_name']))
            except KeyError:
                logging.warning("Unable to find 'file_name' key for image {}".format(image))
    return coco


def drop_duplicates(list_: list):
    """

    Args:
        list_: Drop duplicate entries of dictionaries based on their key/value pairs

    Returns: List of dropped duplicates

    """
    def to_tuple(list_entry: list):
        return tuple(to_tuple(i) if isinstance(i, list) else i for i in list_entry)
    return [dict(i) for i in set(to_tuple([list(i) for i in sorted(i.items())]) for i in list_)]


def load_coco(json_buffer: str) -> COCO:
    json_buffer = json_buffer.strip()
    if not json_buffer:
        # Empty file check
        logging.error("Expecting input from stdin: received empty characters {}".format(repr(json_buffer)))
        sys.exit(1)
    with redirect_stdout(Verbose):
        coco = COCO()
        coco.dataset = json.loads(json_buffer)
        coco.createIndex()
    return coco


def grouper(iterable, size: int, fillvalue=None):
    """

    Args:
        iterable: Data structure that can be iterated through
        size: Size by which to group values together
        fillvalue: Fill value for missing values

    Returns: Tuples of grouped values

    """
    args = [iter(iterable)] * size
    return itertools.zip_longest(*args, fillvalue=fillvalue)


def assign_new_image_ids(coco: COCO, args: argparse.Namespace) -> COCO:
    """Assigning new image id methods"""
    logging.info("assign-new-image-ids operation selected")
    if args.assign_method == 'sort':
        return assign_from_sorted(coco, args)
    elif args.assign_method == 'coco':
        return assign_from_coco(coco, args)
    logging.warning("Output coco is the same as input coco")
    return coco


def assign_from_coco(stdin_coco: COCO, args: argparse.Namespace) -> COCO:
    """

    Args:
        stdin_coco: COCO file read from stdin
        args: arguments passed from argparse

    Returns: COCO file with image ids that have been reassigned based on the image ids from a command line COCO file

    """
    old_id_2_key = {image_entry['id']: image_entry[args.key] for image_entry in stdin_coco.dataset['images']}
    with open(args.coco) as f:
        command_line_coco = json.load(f)
    key_2_new_id = {image_entry[args.key]: image_entry['id'] for image_entry in command_line_coco['images']}
    all_ids = set(range(len(stdin_coco.dataset['images']) + len(command_line_coco['images'])))
    new_ids = {new_id for new_id in key_2_new_id.values()}
    available_ids = all_ids - new_ids
    old_id_2_new_id = {}
    drop_image_ids = set()
    drop_ann_ids = set()
    for old_id, key in old_id_2_key.items():
        if key not in key_2_new_id.keys():
            old_id_2_key[old_id] = available_ids.pop()
    for i, image_entry in enumerate(stdin_coco.dataset['images']):
        try:
            image_entry['id'] = key_2_new_id[old_id_2_key[image_entry['id']]]
        except KeyError:
            if args.drop:
                drop_image_ids.add(i)
            # current image entry key does not exist in the command line COCO file
            logging.warning("Image entry with id {} and key: value -> {}: {} cannot be found on command line COCO file".format(image_entry['id'], args.key, image_entry[args.key]))
            logging.warning("ID {} will be assigned to image entry with id {}".format(old_id_2_new_id[image_entry['id']], image_entry['id']))
            image_entry['id'] = old_id_2_new_id[image_entry['id']]

    for i, ann_entry in enumerate(stdin_coco.dataset['annotations']):
        try:
            ann_entry['image_id'] = key_2_new_id[old_id_2_key[ann_entry['image_id']]]
        except KeyError:
            if args.drop:
                drop_ann_ids.add(i)
            logging.warning("This annotation has an image that could not be matched")
            ann_entry['image_id'] = old_id_2_new_id[ann_entry['image_id']]
    for i in drop_image_ids:
        del stdin_coco.dataset['images'][i]
    for i in drop_ann_ids:
        del stdin_coco.dataset['annotations'][i]
    return stdin_coco


def assign_from_sorted(coco: COCO, args: argparse.Namespace) -> COCO:
    """

    Args:
        coco: COCO file read from stdin
        args: arguments pass from argparse

    Returns: COCO file with image ids that have been reassigned based on the sorted order of the images from args.key

    """
    old_id_2_path = {image['id']: image['path'] for image in coco.dataset['images']}
    from operator import itemgetter
    coco.dataset['images'].sort(key=itemgetter(args.key))
    for i, image_entry in enumerate(coco.dataset['images']):
        image_entry['id'] = i
    path_2_new_id = {image_entry['path']: image_entry['id'] for image_entry in coco.dataset['images']}
    for annotation in coco.dataset['annotations']:
        annotation['image_id'] = path_2_new_id[old_id_2_path[annotation['image_id']]]
    return coco


def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=_DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    subparsers = parser.add_subparsers(title="Operations", description=_PARSER_DESCRIPTION, help="Available operations")

    parser_crop = subparsers.add_parser('crop',                     help="Crop images and annotations; currently supports only cropping images", description=_CROP_DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_crop.add_argument('--fit',                               help="if centre of cropped area to close to border, shift cropped area to fit inside image", action='store_true')
    parser_crop.add_argument('--keep-partial',                      help="keep partially cropped annotations: todo", action='store_true')
    parser_crop.add_argument('--point',                             help="centre of cropped area identified by annotation_type 'point'", action='store_true')
    parser_crop.add_argument('-s', '--size',                        help="<width>,<height> crop size", type=str)

    parser_resize = subparsers.add_parser('resize',                 help="Resize all images and their respective annotations by a scaling factor or to specified width and height", description=_RESIZE_DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_resize_mx = parser_resize.add_mutually_exclusive_group(required=True)
    parser_resize.add_argument('-d', '--digits',                    help="Number of decimal digits in bbox and segmentation coordinates; default: %(default)s", type=int, default=None)
    parser_resize_mx.add_argument('-f', '--factor',                 help="Scale images by a percentage", type=float)
    parser_resize_mx.add_argument('-s', '--size',                   help="[width],[height] output size", type=str)

    parser_remap = subparsers.add_parser('remap',                   help="Remap categories and/or category id", description=_REMAP_DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_remap.add_argument('mapping',                            help="Dict style string for remapping of either category id/category name to category id/category name", type=str)
    parser_remap.add_argument('--target-categories',                help="Target categories to be used for re-mapping. Same format as default COCO categories list. Default categories is taken from input COCO JSON file", type=str)
    parser_remap.add_argument('--keep-source-categories',           help="If target categories is specified, append target to input categories", action='store_true')

    parser_repath = subparsers.add_parser('repath',                 help="Re-path key value pairs for path for every image in COCO JSON.", description=_REPATH_DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_repath.add_argument('path',                              help="New path to prepend to each image in data set", type=str)

    parser_new_ids = subparsers.add_parser('assign-new-image-ids',  help="Assign new ids to COCO file from stdin based on ids from COCO file passed as command line argument.", description=_ASSIGN_NEW_IMAGE_IDS_DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_new_ids.add_argument('--drop',                           help="Drop image if the key to match by does not exist from the COCO file passed from command line", action='store_true')

    subparser_new_ids = parser_new_ids.add_subparsers(dest='assign_method')
    parser_sort = subparser_new_ids.add_parser('sort',              help="Sort images by a given key and assign new ids based on ordering")
    parser_sort.add_argument('-k', '--key',                         help="Key to sort by. If no key is given, assigned new image ids based on existing ordering", type=str)

    parser_coco = subparser_new_ids.add_parser('coco',              help="Match images from stdin COCO with command line COCO by key and assign new image ids from command line COCO.")
    parser_coco.add_argument('coco',                                help="COCO file to assign image ids from.", type=str)
    parser_coco.add_argument('-k', '--key',                         help="Key to match by. Default is %(default)s.", type=str, default='path')

    parser.add_argument('-m', '--minified',                         help="Disable JSON pretty print", action='store_const', const=None, default=4, dest='indent')
    parser.add_argument('-v', '--verbose',                          help="More output to stderr", action='store_const', const=logging.INFO)

    apply_to_images_args = ['--apply-to-images']
    apply_to_images_kwargs = {'action': 'store_true',
                              'help'  : 'Apply operation to images, output to directory specified by --images-output-dir'}

    image_output_dir_args = ['-o', '--image-output-dir']
    image_output_dir_kwargs = {'type'   : str,
                               'default': 'images',
                               'help'   : 'Image output directory; default %(default)s'}

    parser_crop.add_argument(*apply_to_images_args, **apply_to_images_kwargs)
    parser_crop.add_argument(*image_output_dir_args, **image_output_dir_kwargs)

    parser_resize.add_argument(*apply_to_images_args, **apply_to_images_kwargs)
    parser_resize.add_argument(*image_output_dir_args, **image_output_dir_kwargs)

    parser_crop.set_defaults(func=crop)
    parser_resize.set_defaults(func=resize)
    parser_remap.set_defaults(func=remap)
    parser_repath.set_defaults(func=repath)
    parser_new_ids.set_defaults(func=assign_new_image_ids)

    return parser.parse_args()


class Verbose:
    @staticmethod
    def write(line):
        line = line.strip()
        if line:
            logging.info(line)


if __name__ == '__main__':
    main(get_args())
