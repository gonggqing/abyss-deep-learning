#!/usr/bin/env python3
import argparse
import itertools
import json
import os
import sys
from contextlib import redirect_stdout

from pycocotools.coco import COCO

DESCRIPTION = \
    """
Read COCO json file piped in from stdin or a list of COCO json files and apply image manipulation and 
processing. Output new COCO json file with relevant changes to the data and if output images is specified, 
output an image directory in the current working directory with all modified images.

RLE not currently supported for segmentation resizing
tile action is currently dummy action for demonstration purposes

examples:
    cat coco.json | coco-calc --apply-to-images tile --tiles 4,5
    cat coco.json | coco-calc resize --factor 0.3
    cat coco.json | coco-calc --verbose resize --size 480,640
    
    cat pf.json | coco-calc remap "{1:1,2:1,3:1,4:1}" -c "{1:PF}"
    cat pf.json | coco-calc remap "{'PF-G':'PF','PF-L':'PF','PF-M':'PF','PF-H':'PF'}"
"""


def main():
    global ARGS
    ARGS = get_args()
    say("creating coco object")
    coco = ARGS.func(load_coco(sys.stdin.read()))
    json.dump(coco.dataset, sys.stdout, indent=ARGS.indent)
    say("done")
    sys.exit()


def remap(coco: COCO) -> COCO:
    from ast import literal_eval
    say("remapping categories")
    mapping = literal_eval(ARGS.mapping)
    old_id_2_new_id, old_id_2_new_str, old_str_2_new_id, old_str_2_new_str = {}, {}, {}, {}
    for old, new in mapping.items():
        if isinstance(old, int) and isinstance(new, int):
            old_id_2_new_id[old] = new

        elif isinstance(old, int) and isinstance(new, str):
            old_id_2_new_str[old] = new

        elif isinstance(old, str) and isinstance(new, int):
            old_str_2_new_id[old] = new

        elif isinstance(old, str) and isinstance(new, str):
            old_str_2_new_str[old] = new

    coco_categories = coco.loadCats(coco.getCatIds())
    for cat in coco_categories:
        if cat['id'] in old_id_2_new_id:
            for ann in coco.loadAnns(coco.getAnnIds(catIds=cat['id'])):
                ann['category_id'] = old_id_2_new_id[cat['id']]
            cat['id'] = old_id_2_new_id[cat['id']]

        elif cat['id'] in old_id_2_new_str:
            cat['name'] = old_id_2_new_str[cat['id']]

        elif cat['name'] in old_str_2_new_id:
            for ann in coco.loadAnns(coco.getAnnIds(catIds=coco.getCatIds(catNms=cat['name']))):
                ann['category_id'] = old_str_2_new_id[cat['name']]
            cat['id'] = old_str_2_new_id[cat['name']]

        elif cat['name'] in old_str_2_new_str:
            cat['name'] = old_str_2_new_str[cat['name']]

        else:
            say("skipping category", json.dumps(cat, indent=4))

    # Relabel categories with specific ids after having given new ids
    if ARGS.categories:
        categories = literal_eval(ARGS.categories)
        for cat in coco_categories:
            cat['name'] = categories[cat['id']]

    coco.dataset['categories'] = [dict(tple) for tple in {tuple(dct.items()) for dct in coco_categories}]

    category_ids = coco.getCatIds()
    if len(set(category_ids)) != len(category_ids):
        say('warning, there are duplicate ids in the coco dataset')

    return coco


def resize(coco: COCO) -> COCO:
    say("resizing images")
    if ARGS.apply_to_images:
        os.makedirs(os.path.join(os.getcwd(), 'images'), exist_ok=True)
    for img_data in coco.loadImgs(coco.getImgIds()):
        if ARGS.factor is not None:
            h_scale = v_scale = ARGS.factor
        else:
            dims = ARGS.size.split(',')
            h_scale = int(dims[0]) / img_data['width']
            v_scale = int(dims[1]) / img_data['height']
        img_data['height'] = int(img_data['height'] * v_scale)
        img_data['width'] = int(img_data['width'] * h_scale)

        if ARGS.apply_to_images:
            import cv2
            path = None
            basenames = set()
            if os.path.isfile(img_data['path']):
                path = img_data['path']
            elif os.path.isfile(os.path.abspath(img_data['path'])):
                path = img_data['path']
            else:
                say("cannot find path to image [{}]".format(img_data['path']))

            if path is not None:
                img = cv2.imread(img_data['path'])
                new_path = os.path.join(os.getcwd(), 'images', os.path.basename(img_data['path']))
                if new_path in basenames:
                    print('coco-calc: resize: expected unique image filenames, got duplicated "{}"'.format(new_path),
                          file=sys.stderr)
                    sys.exit(1)
                img_data['path'] = new_path
                img_size = (img_data['width'], img_data['height'])
                resized_img = cv2.resize(img, img_size)
                # os.makedirs( new_path, exist_ok = True )
                say("writing image to {}".format(new_path))
                cv2.imwrite(new_path, resized_img)

        anns = coco.loadAnns(coco.getAnnIds(img_data['id']))
        # Rescaling bbox and segmentation values
        # format is [x, y, width, height]
        # Rescaled area value i.e. new_width * new_height
        for ann in anns:
            x = int(ann['bbox'][0] * h_scale)
            y = int(ann['bbox'][1] * v_scale)
            width = int(ann['bbox'][2] * h_scale)
            height = int(ann['bbox'][3] * v_scale)
            ann['bbox'] = [x, y, width, height]
            ann['area'] = width * height

            if 'segmentation' in ann:
                tmp = ann['segmentation']
                if type(tmp) is list:
                    segmentation = []
                    for segment in tmp:
                        new_segment = [(int(x * h_scale), int(y * v_scale)) for x, y in grouper(segment, 2)]
                        # Flatten the list of tuples
                        new_segment = list(itertools.chain(*new_segment))
                        segmentation.append(new_segment)
                    ann['segmentation'] = segmentation
                elif type(tmp) is dict:
                    say("rle is not yet supported")
                else:
                    say("unknown data type [{}]".format(type(tmp)))
            else:
                say("warning: annotation with id", ann['id'], "does not have 'segmentation'; ignored")
    return coco


# Placeholder for demonstration purposes
def tile(coco: COCO) -> COCO:
    say("tiling images")
    return coco


def load_coco(json_buffer: str) -> COCO:
    with redirect_stdout(Verbose):
        coco = COCO()
        coco.dataset = json.loads(json_buffer)
        coco.createIndex()
    return coco


def say(*args, **kwargs):
    if ARGS.verbose:
        print("{}:".format(os.path.basename(__file__)), *args, file=sys.stderr, **kwargs)


def grouper(iterable, n: int, fillvalue=None):
    args = [iter(iterable)] * n
    return itertools.zip_longest(*args, fillvalue=fillvalue)


def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    subparsers = parser.add_subparsers(title="Actions", description="Actions apply to all images in the dataset. "
                                                                    "For more information on each "
                                                                    "individual action, append -h",
                                       help="Available actions")

    args = ['-o', '--apply-to-images']
    kwargs = {
        'action': 'store_true',
        'help'  : 'Apply action to images and output in current working directory an [image] folder that contains the '
                  'new images'
    }
    parser_resize = subparsers.add_parser('resize', help="Resize all images and their respective annotations by a "
                                                         "scaling factor or to specified width and height")
    parser_resize.set_defaults(func=resize)
    resize_args = parser_resize.add_mutually_exclusive_group(required=True)

    def restricted_float(x):
        x = float(x)
        if x < 0.0 or x > 1.0:
            raise argparse.ArgumentTypeError("{factor} not in range [0.0, 1.0]".format(factor=x))
        return x

    resize_args.add_argument('-f', '--factor', type=restricted_float, help="Scale images by a percentage")
    resize_args.add_argument('-s', '--size', type=str, help="[width],[height] to resize images to")
    resize_args.add_argument(*args, **kwargs)

    parser_remap = subparsers.add_parser('remap', help="Remap categories and/or category id")
    parser_remap.set_defaults(func=remap)
    parser_remap.add_argument('mapping', type=str, help="Dict style string for remapping of either category "
                                                        "id/category name to category id/category name")
    parser_remap.add_argument('-c', '--categories', type=str, help="Use to rename category name after new category "
                                                                   "ids have been assigned. Input argument is in "
                                                                   "similar form as mapping")

    parser_tile = subparsers.add_parser('tile', help="For testing purposes, no functionality currently")
    parser_tile.set_defaults(func=tile)
    tile_args = parser_tile.add_mutually_exclusive_group(required=True)
    tile_args.add_argument('-n', '--num-tiles', type=int, help="Number of tiles to generate from image")
    tile_args.add_argument('--dummy', help="dummy option")
    tile_args.add_argument(*args, **kwargs)

    parser.add_argument('-m', '--min', '--minified', action='store_const', help="Output minimised json", const=None,
                        default=4, dest='indent')
    parser.add_argument('-v', '--verbose', action='store_true', help="More output to stderr")
    return parser.parse_args()


class Verbose:
    @staticmethod
    def write(line):
        line = line.strip()
        if line:
            say(line)


if __name__ == '__main__':
    main()
