#!/usr/bin/env python3
import argparse
import itertools
import json
import os
import sys
from operator import itemgetter

from pycocotools.coco import COCO

SCRIPT_NAME = os.path.basename(__file__)

DESCRIPTION = \
"""
Read JSON file(s) defined on command line or a list of JSON files on stdin and apply a search for images given a 
boolean expression of captions to search for. 

examples:
    coco-grep coco.json --expression "JD and F"
    coco-merge coco_a.json coco_b.json | coco-grep --expression "RI and F"
"""


def main(args):
    stdin_string = ""
    if not sys.stdin.isatty():
        for line in sys.stdin:
            stdin_string += line.strip()

    if stdin_string:
        args.json_file.append(stdin_string)

    new_data_set = {
        'images': [],
        'annotations': [],
    }

    for json_file_path_or_buffer in args.json_files:
        say("creating coco object")
        coco = load_coco(json_file_path_or_buffer)

        # Pre-parse the data set for all available keys
        unique_captions = {value['caption']: False for key, value in coco.anns.items()}

        # Raise exception when grepped caption can not be found in the data set
        globals().update(unique_captions)
        try:
            eval(args.expression)
        except NameError as err:
            raise RuntimeError("Caption [{}] could not be found in the given data set".format(str(err).split("'")[1]))

        # Find the minimum set combination satisfies the expression so as to find images that have the minimum
        # required captions

        # TODO: Refactor code, not very efficient, could be implemented better
        if args.exact_match:
            min_expr = None
            for i in range(len(unique_captions) + 1):
                combs = list(itertools.combinations(unique_captions.keys(), i))
                for comb in combs:
                    for caption in comb:
                        globals()[caption] = True
                    if eval(args.expression):
                        min_expr = set(comb)
                        break
                    for caption in comb:
                        globals()[caption] = False
                if min_expr is not None:
                    break

        globals().update(unique_captions)

        # Sort the annotations
        anns = coco.loadAnns(coco.getAnnIds())
        anns.sort(key=itemgetter('image_id', 'id'))

        curr_img_id = None
        captions = []
        say("copying captions")
        for idx, ann in enumerate(anns):
            # Captions have been merged for current image
            if curr_img_id != ann['image_id']:
                if args.exact_match:
                    if set(captions) != min_expr:
                        curr_img_id = ann['image_id']
                        captions.clear()
                        continue

                for caption in captions:
                    globals()[caption] = True

                if eval(args.expression):
                    # Add the image annotations and image to the new COCO file
                    # Choose to either add all associated annotations, or only annotations in grep
                    start_id = idx - len(captions)
                    end_id = idx
                    for i in range(start_id, end_id):
                        if anns[i]['caption'] in unique_captions:
                            new_data_set['annotations'].append(anns[i])

                # Reset global captions
                for caption in captions:
                    globals()[caption] = False

                # Empty caption list for next image
                curr_img_id = ann['image_id']
                captions.clear()

            captions.append(ann['caption'])

        say("copying images")
        # Iterate through annotations and add associated images to new dataset
        for img in coco.loadImgs(coco.getImgIds()):
            img_ids = [ann['image_id'] for ann in new_data_set['annotations']]
            if img['id'] in img_ids:
                # Skip images that have been added already
                if img in new_data_set['images']:
                    continue

                new_data_set['images'].append(img)

    json.dump(new_data_set, sys.stdout, indent=4)
    say("done")
    sys.exit()


def load_coco(json_file_path_or_buffer):
    if os.path.exists(json_file_path_or_buffer):
        coco = COCO(json_file_path_or_buffer)
    else:
        coco = COCO()
        coco.dataset = json.loads(json_file_path_or_buffer)
        coco.createIndex()
    return coco


def say(*args, **kwargs):
    print("{}:".format(SCRIPT_NAME), *args, file=sys.stderr, **kwargs)


def get_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('json_files', nargs='*', type=str, help="JSON files to grep from")
    parser.add_argument('-e', '--expression', type=str, help="Boolean expression to search for image captions in an "
                                                             "image")
    parser.add_argument('-x', '--exact-match', action='store_true',
                        help="Include only images with exact match to the given label (ie not roots & joint, just roots")
    return parser.parse_args()


if __name__ == '__main__':
    main(get_args())
