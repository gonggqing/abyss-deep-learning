#!/usr/bin/env python3
from __future__ import print_function

import argparse
import json
import sys
import itertools

from contextlib import redirect_stdout
from operator import itemgetter

from pycocotools.coco import COCO


def main(args):
    # TODO: what are edge cases for this function isatty()?
    if not sys.stdin.isatty():
        for line in sys.stdin:
            args.json_files.append(line.strip())

    for json_file in args.json_files:
        with redirect_stdout(sys.stderr):
            coco = COCO(json_file)
            new_dataset = {
                'images': [],
                'annotations': [],
            }

        # Pre-parse the dataset for all available keys
        unique_captions = {value['caption']: False for key, value in coco.anns.items()}
        globals().update(unique_captions)

        # Find the minimum set combination satisfies the expression so as to find images that have the minimum
        # required captions

        # TODO: Refactor code, not very efficient, could be implemented better
        if args.exclude_multiple:
            min_expr = None
            for i in range(len(unique_captions) + 1):
                combs = list(itertools.combinations(unique_captions.keys(), i))
                for comb in combs:
                    for caption in comb:
                        globals()[caption] = True
                    if eval(args.expression):
                        min_expr = set(comb)
                        break
                    for caption in comb:
                        globals()[caption] = False
                if min_expr is not None:
                    break

        # Sort the annotations
        anns = coco.loadAnns(coco.getAnnIds())
        anns.sort(key=itemgetter('image_id', 'id'))

        curr_img_id = None
        captions = []
        for idx, ann in enumerate(anns):
            # Captions have been merged for current image
            if curr_img_id != ann['image_id']:
                if args.exclude_multiple:
                    if set(captions) != min_expr:
                        curr_img_id = ann['image_id']
                        captions.clear()
                        continue

                for caption in captions:
                    globals()[caption] = True

                if eval(args.expression):
                    # Add the image annotations and image to the new COCO file
                    # Choose to either add all associated annotations, or only annotations in grep
                    start_id = idx - len(captions)
                    end_id = idx
                    for i in range(start_id, end_id):
                        if anns[i]['caption'] in unique_captions:
                            new_dataset['annotations'].append(anns[i])

                # Reset global captions
                for caption in captions:
                    globals()[caption] = False

                # Empty caption list for next image
                curr_img_id = ann['image_id']
                captions.clear()

            captions.append(ann['caption'])

        # Iterate through annotations and add associated images to new dataset
        for img in coco.loadImgs(coco.getImgIds()):
            img_ids = [ann['image_id'] for ann in new_dataset['annotations']]
            if img['id'] in img_ids:
                # Skip images that have been added already
                if img in new_dataset['images']:
                    continue

                new_dataset['images'].append(img)

        json.dump(new_dataset, sys.stdout, sort_keys=True, indent=4)

    sys.exit(0)


def get_args():
    parser = argparse.ArgumentParser(
        description="Split a COCO JSON database into multiple."
    )
    parser.add_argument('json_files', nargs='+', type=str, help='JSON file to grep from')
    parser.add_argument('--caption', type=str, help="extract given caption")
    parser.add_argument('--exclude-multiple', action='store_true',
                        help='Include only images with JUST the given label (ie not roots & joint, just roots')
    parser.add_argument('--expression', '--expr', type=str, help="todo")
    # parser.add_argument('--all-annotations', action='store_true', help='Include all associated image annotations when '
    #                                                                   'creating the new dataset')
    # parser.add_argument('--invert-match', '-v', action='store_true', help='invert match')

    args = parser.parse_args()
    return args


if __name__ == '__main__':
    main(get_args())
