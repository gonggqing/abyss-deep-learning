#!/usr/bin/env python3
import argparse
import json
import os
import sys
from contextlib import redirect_stdout
from operator import itemgetter

from pycocotools.coco import COCO

DESCRIPTION = \
"""
Read COCO json file piped in from stdin or a list of COCO json files and grep for images and all associated 
annotations using a given expression. 

Possible expressions that can be used are:
    img_id/image_id
    cat_id/category_id
    cat/category
    supcat/supercategory
    multiple cats/categories i.e. 'JD' in cats/categories and 'F' in cats/categories
    multiple supcats/supercategories i.e. 'JD' in supcats/supercategories or 'F' in supcats/supercategories

examples:
    coco-grep coco.json -e "img_id == 10"
    coco-grep coco.json --expression "image_id == 5"
    
    coco-grep coco.json -e "cat_id == 2"
    coco-grep coco.json --expression "category_id == 3"
    
    coco-grep coco.json -e "cat == 'JD'"
    coco-grep coco.json -expression "category == 'RI'"
    
    coco-grep coco.json -e "'JD' in cats and 'RI' in cats"
    coco-grep coco.json --expression "'JD' in categories or 'F' in categories"
    
    coco-grep coco.json -e "not 'C' in supcats and 'ED' in supcats"
    coco-grep coco.json --expression "not 'JD' in categories or 'F' in categories"
"""


def main():
    global ARGS
    ARGS = get_args()

    if not sys.stdin.isatty():
        stdin_string = sys.stdin.read()
        if stdin_string:
            ARGS.json_files.append(stdin_string)

    for idx, json_file_path_or_buffer in enumerate(ARGS.json_files):
        say("creating coco object")
        coco = load_coco(json_file_path_or_buffer)

        all_cats = {cat['name'].replace('-', '_'): False for cat in coco.loadCats(coco.getCatIds()) if cat['name']}
        globals().update(all_cats)

        all_supcats = {cat['supercategory'].replace('-', '_'): False for cat in coco.loadCats(coco.getCatIds()) if
                       cat['supercategory']}
        globals().update(all_supcats)

        # Load all annotations
        anns = coco.loadAnns(coco.getAnnIds())

        # Sort all annotations by their image id, then the annotation id as an image can have multiple annotations
        anns.sort(key=itemgetter('image_id', 'id'))

        # Image ids to carry over from COCO dataset
        to_add_img_ids = set()

        # Annotation ids to carry over from COCO dataset
        to_add_ann_ids = set()

        for curr_img_id in coco.getImgIds():
            # Reinitialize image id for expression check
            img_id = image_id = None

            # Reinitialize category id for expression check
            cat_ids = category_ids = []
            cat_id = category_id = None

            # Reinitialize category for expression check
            globals().update(all_cats)
            cats = categories = []
            cat = category = None

            # Reinitialize super category for expression check
            globals().update(all_supcats)
            supcats = supercategories = []
            supcat = supercategory = None

            # Check expression for image id i.e. image_id == 1
            img_id = image_id = curr_img_id
            if eval(ARGS.expression):
                to_add_img_ids.add(curr_img_id)

            # Check expression for category_id ie. category_id == 2
            cat_ids = category_ids = set(
                [ann['category_id'] for ann in coco.loadAnns(coco.getAnnIds(imgIds=curr_img_id))])
            if eval(ARGS.expression):
                to_add_img_ids.add(curr_img_id)

            for tmp in cat_ids:
                cat_id = category_id = tmp
                if eval(ARGS.expression):
                    to_add_img_ids.add(curr_img_id)

            # Check expression for category/ies i.e. 'JD' and 'RI' OR 'JD' in categories and 'RI' in categories
            globals().update({cat['name'].replace('-', '_'): True for cat in coco.loadCats(cat_ids) if cat['name']})
            cats = categories = [cat['name'] for cat in coco.loadCats(cat_ids) if cat['name']]
            if eval(ARGS.expression):
                to_add_img_ids.add(curr_img_id)

            # Check for single category i.e. category == 'JD'
            for tmp in categories:
                cat = category = tmp
                if eval(ARGS.expression):
                    to_add_img_ids.add(curr_img_id)

            # Check expression for supercategory/ies
            globals().update({cat['supercategory'].replace('-', '_'): True for cat in coco.loadCats(cat_ids) if
                              cat['supercategory']})
            supcats = supercategories = [cat['supercategory'] for cat in coco.loadCats(cat_ids) if cat['supercategory']]
            if eval(ARGS.expression):
                to_add_img_ids.add(curr_img_id)

            for tmp in supercategories:
                supcat = supercategories = tmp
                if eval(ARGS.expression):
                    to_add_img_ids.add(curr_img_id)

        to_add_ann_ids = coco.getAnnIds(imgIds=to_add_img_ids)

        if ARGS.keep_cats is not None:
            keep_cats = ARGS.keep_cats.split(',')
            tmp = to_add_ann_ids.copy()
            to_add_ann_ids.clear()
            cat_id_2_cat = {cat['id']: cat['name'] for cat in coco.loadCats(coco.getCatIds())}
            for ann in coco.loadAnns(tmp):
                cat_id = ann['category_id']
                if cat_id_2_cat[cat_id] in keep_cats or str(cat_id) in keep_cats:
                    to_add_ann_ids.append(ann['id'])

        coco.dataset['images'] = coco.loadImgs(to_add_img_ids)
        coco.dataset['annotations'] = coco.loadAnns(to_add_ann_ids)

        json.dump(coco.dataset, sys.stdout, indent=4)
        say("finished file {}".format(idx + 1))

        # TODO: Look into caption compatibility with other COCO json format
        """
        # Pre-parse the data set for all available keys
        unique_captions = {value['caption']: False for key, value in coco.anns.items()}

        # Raise exception when grepped caption can not be found in the data set
        globals().update(unique_captions)
        try:
            eval(ARGS.captions)
        except NameError as err:
            raise RuntimeError("Caption [{}] could not be found in the given data set".format(str(err).split("'")[1]))

        # Find the minimum set combination satisfies the captions so as to find images that have the minimum
        # required captions

        # TODO: Refactor code, not very efficient, could be implemented better
        if ARGS.exact_match:
            min_expr = None
            for i in range(len(unique_captions) + 1):
                combs = list(itertools.combinations(unique_captions.keys(), i))
                for comb in combs:
                    for caption in comb:
                        globals()[caption] = True
                    if eval(ARGS.captions):
                        min_expr = set(comb)
                        break
                    for caption in comb:
                        globals()[caption] = False
                if min_expr is not None:
                    break

        globals().update(unique_captions)

        # Sort the annotations
        anns = coco.loadAnns(coco.getAnnIds())
        anns.sort(key=itemgetter('image_id', 'id'))

        curr_img_id = None
        captions = []
        say("copying captions")
        for idx, ann in enumerate(anns):
            # Captions have been merged for current image
            if curr_img_id != ann['image_id']:
                if ARGS.exact_match:
                    if set(captions) != min_expr:
                        curr_img_id = ann['image_id']
                        captions.clear()
                        continue

                for caption in captions:
                    globals()[caption] = True

                if eval(ARGS.captions):
                    # Add the image annotations and image to the new COCO file
                    # Choose to either add all associated annotations, or only annotations in grep
                    start_id = idx - len(captions)
                    end_id = idx
                    for i in range(start_id, end_id):
                        if anns[i]['caption'] in unique_captions:
                            new_data_set['annotations'].append(anns[i])

                # Reset global captions
                for caption in captions:
                    globals()[caption] = False

                # Empty caption list for next image
                curr_img_id = ann['image_id']
                captions.clear()

            captions.append(ann['caption'])

        say("copying images")
        # Iterate through annotations and add associated images to new dataset
        for img in coco.loadImgs(coco.getImgIds()):
            img_ids = [ann['image_id'] for ann in new_data_set['annotations']]
            if img['id'] in img_ids:
                # Skip images that have been added already
                if img in new_data_set['images']:
                    continue

                new_data_set['images'].append(img)

        json.dump(new_data_set, sys.stdout, indent=4)
        """
    say("done")
    sys.exit()


def load_coco(json_file_path_or_buffer):
    with redirect_stdout(Verbose):
        if os.path.exists(json_file_path_or_buffer):
            coco = COCO(json_file_path_or_buffer)
        else:
            coco = COCO()
            coco.dataset = json.loads(json_file_path_or_buffer)
            coco.createIndex()
    return coco


class Verbose:
    @staticmethod
    def write(line: str):
        line = line.strip()
        if line:
            say(line)


def say(*args, **kwargs):
    if ARGS.verbose:
        print("{}:".format(os.path.basename(__file__)), *args, file=sys.stderr, **kwargs)


def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('json_files', nargs='*', type=str, help="JSON files to grep from")
    parser.add_argument('-e', '--expression', type=str, help="General expression to search for images")
    parser.add_argument('-c', '--keep-cats', type=str, help="Specify specific categories or category ids (comma "
                                                            "separated) to keep for each image")
    parser.add_argument('-v', '--verbose', action='store_true', help="More output")
    return parser.parse_args()


if __name__ == '__main__':
    main()
