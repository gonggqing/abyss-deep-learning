#!/usr/bin/env python3
import argparse
import json
import os
import sys
from contextlib import redirect_stdout
from operator import itemgetter

from pycocotools.coco import COCO

DESCRIPTION = \
    """
Read COCO json file piped in from stdin or a list of COCO json files and grep for images and all associated 
annotations using a given expression. 

Possible expressions that can be used are:
    img_id/image_id
    cat_id/category_id
    cat/category
    supcat/supercategory
    multiple cats/categories i.e. 'JD' in cats/categories and 'F' in cats/categories
    multiple supcats/supercategories i.e. 'JD' in supcats/supercategories or 'F' in supcats/supercategories

examples:
    coco-grep coco.json -e "img_id == 10"
    coco-grep coco.json --expression "image_id == 5"
    
    coco-grep coco.json -e "cat_id == 2"
    coco-grep coco.json --expression "category_id == 3"
    
    coco-grep coco.json -e "cat == 'JD'"
    coco-grep coco.json -expression "category == 'RI'"
    
    coco-grep coco.json -e "'JD' in cats and 'RI' in cats"
    coco-grep coco.json --expression "'JD' in categories or 'F' in categories"
    
    coco-grep coco.json -e "not 'C' in supcats and 'ED' in supcats"
    coco-grep coco.json --expression "not 'JD' in categories or 'F' in categories"
"""


def main():
    global ARGS
    ARGS = get_args()
    ARGS.expression = ARGS.expression.replace('-', '_')

    say("creating coco object")
    coco = load_coco(sys.stdin.read())

    try:
        all_cats = {cat['name'].replace('-', '_'): False for cat in coco.loadCats(coco.getCatIds()) if cat['name']}
    except KeyError:
        say("expected key [categories] in coco file")
        all_cats = {}

    globals().update(all_cats)

    try:
        all_supcats = {cat['supercategory'].replace('-', '_'): False for cat in coco.loadCats(coco.getCatIds()) if
                       cat['supercategory']}
    except KeyError:
        say("expected key [categories] in coco file")
        all_supcats = {}

    globals().update(all_supcats)

    try:
        all_captions = {item['caption']: False for item in coco.anns.values()}
    except KeyError:
        say("expected key [caption] in coco file")
        all_captions = {}

    globals().update(all_captions)

    # Load all annotations
    anns = coco.loadAnns(coco.getAnnIds())

    # Sort all annotations by their image id, then the annotation id as an image can have multiple annotations
    anns.sort(key=itemgetter('image_id', 'id'))

    # Image ids to carry over from COCO dataset
    to_add_img_ids = set()

    global img_id, image_id
    global cat_ids, category_ids
    global cat_id, category_id
    global cats, categories
    global cat, category
    global supcats, supercategories
    global supcat, supercategory
    global caps, captions
    global cap, caption

    for curr_img_id in coco.getImgIds():
        # Reinitialize image id for expression check
        img_id = image_id = None

        # Reinitialize category id for expression check
        cat_ids = category_ids = []
        cat_id = category_id = None

        # Reinitialize category for expression check
        globals().update(all_cats)
        cats = categories = []
        cat = category = None

        # Reinitialize super category for expression check
        globals().update(all_supcats)
        supcats = supercategories = []
        supcat = supercategory = None

        # Reinitialize captions for expression check
        globals().update(all_captions)
        caps = captions = []
        cap = caption = None

        # Check expression for image id i.e. image_id == 1
        img_id = image_id = curr_img_id

        to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for category_ids i.e. 2 in category_ids and 3 in category_ids
        try:
            cat_ids = category_ids = set(
                [ann['category_id'] for ann in coco.loadAnns(coco.getAnnIds(imgIds=curr_img_id))])
        except KeyError:
            say("expected key [category_id] in coco file")

        to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for category_id ie. category_id == 2
        for category_id in cat_ids:
            cat_id = category_id
            to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for categories i.e. 'JD' and 'RI' OR 'JD' in categories and 'RI' in categories
        cats = categories = [cat['name'].replace('-', '_') for cat in coco.loadCats(cat_ids) if cat['name']]
        globals().update(dict.fromkeys(cats, True))
        to_add_img_ids.add(eval_expression(curr_img_id))

        # Check for single category i.e. category == 'JD'
        for category in categories:
            cat = category
            to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for supercategories
        supcats = supercategories = [cat['supercategory'].replace('-', '_') for cat in coco.loadCats(cat_ids) if
                                     cat['supercategory']]
        globals().update(dict.fromkeys(supcats, True))
        to_add_img_ids.add(eval_expression(curr_img_id))

        # Check for single supercategory
        for supercategory in supercategories:
            supcat = supercategory
            to_add_img_ids.add(eval_expression(curr_img_id))

        # Check expression for captions
        try:
            caps = captions = [item['caption'] for item in coco.anns.values() if item['image_id'] == curr_img_id and item['caption']]
            globals().update(dict.fromkeys(caps, True))
            to_add_img_ids.add(eval_expression(curr_img_id))

            for caption in captions:
                cap = caption
                to_add_img_ids.add(eval_expression(curr_img_id))
        except KeyError:
            say("expected key [caption] in dataset")

    to_add_ann_ids = coco.getAnnIds(imgIds=to_add_img_ids)

    if ARGS.keep_cats:
        keep_cats = ARGS.keep_cats.split(',')
        tmp, to_add_ann_ids = to_add_ann_ids, []
        cat_id_2_cat = {cat['id']: cat['name'] for cat in coco.loadCats(coco.getCatIds())}
        for ann in coco.loadAnns(tmp):
            cat_id = ann['category_id']
            if cat_id_2_cat[cat_id] in keep_cats or str(cat_id) in keep_cats:
                to_add_ann_ids.append(ann['id'])

    if ARGS.keep_captions:
        keep_captions = ARGS.keep_captions.split(',')
        tmp, to_add_ann_ids = to_add_ann_ids, []
        for ann in coco.loadAnns(tmp):
            if ann['caption'] in keep_captions:
                to_add_ann_ids.append(ann['id'])

    to_add_img_ids.remove(None)
    imgs = coco.loadImgs(to_add_img_ids)

    coco.dataset['images'] = [] if imgs is None else imgs
    coco.dataset['annotations'] = coco.loadAnns(to_add_ann_ids)

    json.dump(coco.dataset, sys.stdout, indent=4)
    say("done")
    sys.exit()


def eval_expression(img_id):
    try:
        if eval(ARGS.expression):
            return img_id
    except NameError as e:
        say(ARGS.expression)
        say("[{}] is not defined in the dataset".format(str(e).split("'")[1]))


def load_coco(json_buffer: str) -> COCO:
    with redirect_stdout(Verbose):
        coco = COCO()
        coco.dataset = json.loads(json_buffer)
        coco.createIndex()
    return coco


class Verbose:
    @staticmethod
    def write(line: str):
        line = line.strip()
        if line:
            say(line)


def say(*args, **kwargs):
    if ARGS.verbose:
        print("{}:".format(os.path.basename(__file__)), *args, file=sys.stderr, **kwargs)


def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('expression', type=str, help="General expression to search for images")
    parser.add_argument('-cats', '--keep-cats', type=str, help="Specify specific categories or category ids (comma "
                                                               "separated) to keep for each image")
    parser.add_argument('-caps', '--keep-captions', type=str, help="Specify specific captions (comma separated to "
                                                                   "keep for each image")
    parser.add_argument('-v', '--verbose', action='store_true', help="More output")
    return parser.parse_args()


if __name__ == '__main__':
    main()
