#!/usr/bin/env/python3
import argparse
import json
import os
import sys
import time

from pprint import pprint
from contextlib import redirect_stdout

from pycocotools.coco import COCO

# TODO: Update description
DESCRIPTION = \
    """
Read COCO json file piped in from stdin and output to stdout images and !!! ALL associated annotations that satisfy a 
given expression in default COCO format. 

Optional arguments --keep-cats and --keep-caps are there to filter out add annotations as all annotations for on 
image will be copied to the new dataset. Argument to either are comma separated values of categories/captions to 
keep. The new categories/captions will automatically be given new ids.

Possible expressions that can be used are:
    img_id/image_id
    cat_id/category_id
    cat/category
    supcat/supercategory
    multiple cats/categories i.e. 'JD' in cats/categories and 'F' in cats/categories
    multiple supcats/supercategories i.e. 'JD' in supcats/supercategories or 'F' in supcats/supercategories

examples:
    cat coco.json | coco-select-deprecated "img_id == 10".                                             Select all images where image_id is 10 (img_id is an alias for image_id)
    cat coco.json | coco-select-deprecated "image_id == 5".                                            Select all images where image_id is 5
    
    cat coco.json | coco-select-deprecated "cat_id == 2"                                               Select all images that have category_id 2 (cat_id is an alias for category_id)
    cat coco.json | coco-select-deprecated "category_id == 3"                                          Select all images that have category_id 3
    
    cat coco.json | coco-select-deprecated "cat == 'JD'"                                               Select all images that have category JD i.e. joint displacement (cat is an alias for category)
    cat coco.json | coco-select-deprecated "category == 'RI'"                                          Select all images that have category RI i.e. root intrusion
    
    cat coco.json | coco-select-deprecated "'JD' in cats and 'RI' in cats"                             Select all images that have joint displacement AND root intrusion as annotations
    cat coco.json | coco-select-deprecated "'JD' in categories or 'F' in categories"                   Select all images that have either joint displacement OR root intrusion as annotations
    
    cat coco.json | coco-select-deprecated "not 'C' in supcats and 'ED' in supcats"                    Select all images that do not have C i.e. cracks as a supercategory and have ED as a supercategory
    cat coco.json | coco-select-deprecated "not 'JD' in supercategories or 'F' in supercategories"     Select all images that do not have joint displacement or have F i.e. fault as a supercategory
    
    cat coco.json | coco-select-deprecated "img_id in img_ids"                                         Select all images
    
    cat coco.json | coco-select-deprecated "cat == 'JD'" --keep-cats JD                                Select all images that have JD as an annotation and keep ONLY annotations with JD as a category
    cat coco.json | coco-select-deprecated --keep-cats JD,RI,C                                         Select all images and keep only annotations that have JD, RI, or C as a category
    
    cat coco.json | coco-select-deprecated "JD or RI"                                                  Select all images that have JD or RI as an annotation. Does not require quotation marks as the data set is 
                                                                                            pre-parsed for available annotations and creates variables named JD and RI using globals().update    
"""


def main(args: argparse.Namespace = None):
    start = time.perf_counter()
    say("search expressions is [{}]".format(args.expression), verbose=args.verbose)

    say("creating coco object", verbose=args.verbose)
    coco = load_coco(sys.stdin.read())

    # Define globals to evaluate expressions on
    default_keys = {
        'img_id': None,
        'image_id': None,
        'ann_ids': None,
        'annotation_ids': None,
        'ann_id': None,
        'annotation_id': None,
        'cat_ids': [],
        'category_ids': [],
        'cat_id': None,
        'category_id': None,
        'cats': [],
        'categories': [],
        'cat': None,
        'category': None,
        'supcats': [],
        'supercategories': [],
        'supcat': None,
        'supercategory': None,
        'caps': [],
        'captions': [],
        'cap': None,
        'caption': None,
        'bboxes': [],
        'bbox': None,
        'areas': [],
        'area': None,
    }

    if args.on == 'image':
        coco = eval_on_image(coco, args, default_keys)
    elif args.on == 'annotation':
        coco = eval_on_annotation(coco, args, default_keys)

    #json.dump(coco.dataset, sys.stdout, indent=args.indent)
    say("done in {elapsed_time}s".format(elapsed_time=time.perf_counter() - start), verbose=args.verbose)
    sys.exit()


def eval_on_image(coco: COCO, args: argparse.Namespace, default_keys: dict) -> COCO:
    locals().update(default_keys)
    image_ids = coco.getImgIds()

    to_add_img_ids = set()  # Image ids to carry over
    to_add_ann_ids = set()  # Annotation ids to carry over

    for curr_id in image_ids:
        # Reinitialize local keywords for expression check
        locals().update(default_keys)

        # Check expression for image id i.e. image_id == 1
        img_id = image_id = curr_id

        # Check expression for annotation ids
        ann_ids = annotation_ids = coco.getAnnIds(imgIds=image_id)

        # Check expression for category_ids i.e. 2 in category_ids and 3 in category_ids
        cat_ids = category_ids = set([ann['category_id'] for ann in coco.loadAnns(ann_ids) if
                                      'category_id' in ann and ann['category_id']])

        # Check expression for categories i.e. 'JD' and 'RI' OR 'JD' in categories and 'RI' in categories
        cats = categories = [cat['name'] for cat in coco.loadCats(cat_ids) if 'name' in cat and cat['name']]

        # Check expression for supercategories
        supcats = supercategories = [cat['supercategory'] for cat in coco.loadCats(cat_ids) if 'supercategory' in cat
                                     and cat['supercategory']]

        # Check expression for bboxes
        bboxes = [ann['bbox'] for ann in coco.loadAnns(ann_ids) if 'bbox' in ann and ann['bbox']]

        # Check expression for areas
        areas = [ann['area'] for ann in coco.loadAnns(ann_ids) if 'area' in ann and ann['area']]

        # Check expression for captions
        caps = captions = [item['caption'] for item in coco.anns.values() if 'image_id' in item and item['image_id'] ==
                           curr_id and 'caption' in item and item['caption']]

        # Check for single ann id
        for annotation_id in annotation_ids:
            ann_id = annotation_id
            img_id, ann_ids = eval_expression(args.expression, image_id, annotation_ids, locals())
            to_add_img_ids.add(img_id)
            if ann_ids:
                to_add_ann_ids.update(ann_ids)

        # Check expression for category_id ie. category_id == 2
        for category_id in cat_ids:
            cat_id = category_id
            img_id, ann_ids = eval_expression(args.expression, image_id, annotation_ids, locals())
            to_add_img_ids.add(img_id)
            if ann_ids:
                to_add_ann_ids.update(ann_ids)

        # Check for single category i.e. category == 'JD'
        for category in categories:
            cat = category
            if image_id == 10:
                print(cat)
            img_id, ann_ids = eval_expression(args.expression, image_id, annotation_ids, locals())
            to_add_img_ids.add(img_id)
            if ann_ids:
                to_add_ann_ids.update(ann_ids)

        # Check for single supercategory
        for supercategory in supercategories:
            supcat = supercategory
            img_id, ann_ids = eval_expression(args.expression, image_id, annotation_ids, locals())
            to_add_img_ids.add(img_id)
            if ann_ids:
                to_add_ann_ids.update(ann_ids)

        # Check for single bbox
        for bbox in bboxes:
            img_id, ann_ids = eval_expression(args.expression, image_id, annotation_ids, locals())
            to_add_img_ids.add(img_id)
            if ann_ids:
                to_add_ann_ids.update(ann_ids)

        # Check for single bbox
        for area in areas:
            img_id, ann_ids = eval_expression(args.expression, image_id, annotation_ids, locals())
            to_add_img_ids.add(img_id)
            if ann_ids:
                to_add_ann_ids.update(ann_ids)

        # Check for single caption
        for caption in captions:
            cap = caption
            img_id, ann_ids = eval_expression(args.expression, image_id, annotation_ids, locals())
            to_add_img_ids.add(img_id)
            if ann_ids:
                to_add_ann_ids.update(ann_ids)

    to_add_img_ids.discard(None)
    to_add_ann_ids.discard(None)

    coco.dataset['images'] = coco.loadImgs(to_add_img_ids)
    coco.dataset['annotations'] = coco.loadAnns(to_add_ann_ids)
    return coco


def eval_on_annotation(coco: COCO, args: argparse.Namespace, default_keys: dict) -> COCO:
    locals().update(default_keys)
    annotation_ids = coco.getAnnIds()
    to_add_img_ids = set()  # Image ids to carry over
    to_add_ann_ids = set()  # Annotation ids to carry over

    for curr_id in annotation_ids:
        # Reinitialize local keywords for expression check
        locals().update(default_keys)

        ann = coco.loadAnns(curr_id).pop()

        # Check expression for annotation id i.e. annotation_id == 5
        ann_id = annotation_id = curr_id

        # Check expression for image id i.e. image_id == 1
        img_id = image_id = ann['image_id'] if 'image_id' in ann else None

        # Check expression for category id i.e. category_id == 3
        cat_id = category_id = ann['category_id'] if 'category_id' in ann else None

        # Check expression for category i.e. category == 'PF-H'
        cat_dict = coco.loadCats(category_id).pop()
        cat = category = cat_dict['name'] if 'name' in cat_dict else None

        # Check expression for category i.e. supercategory == 'PF'
        supcat = supercategory = cat_dict['supercategory'] if cat_dict is not None and 'supercategory' in cat_dict else None

        # Check expression for bbox
        bbox = ann['bbox'] if 'bbox' in ann else None

        # Check expression for area
        area = ann['area'] if 'area' in ann else None

        # Check expression for category i.e. caption == 'RI' (for classification task)
        cap = caption = ann['caption'] if 'caption' in ann else None

        img_id, ann_id = eval_expression(args.expression, img_id, ann_id, locals())
        if img_id is not None and ann_id is not None:
            say("selecting image id {image_id} and annotation id {ann_id}".format(image_id=img_id, ann_id=ann_id),
                verbose=args.verbose)
        to_add_img_ids.add(img_id)
        to_add_ann_ids.add(ann_id)

    to_add_ann_ids.discard(None)
    to_add_img_ids.discard(None)

    coco.dataset['annotations'] = coco.loadAnns(to_add_ann_ids)
    coco.dataset['images'] = coco.loadImgs(to_add_img_ids)

    return coco


def eval_expression(expression: str, img_id: int, ann_id: int, default_keys: dict):
    locals().update(default_keys)
    ret_img_id = ret_ann_id = None
    try:
        if eval(expression):
            ret_img_id, ret_ann_id = img_id, ann_id
    except NameError as e:
        pass
    except TypeError as e:
        pass
    return ret_img_id, ret_ann_id


def load_coco(json_buffer: str) -> COCO:
    with redirect_stdout(Verbose):
        coco = COCO()
        coco.dataset = json.loads(json_buffer)
        coco.createIndex()
    return coco


class Verbose:
    @staticmethod
    def write(line: str):
        line = line.strip()
        if line:
            say(line)


def debug(*args, **kwargs):
    say(*args, verbose=True, **kwargs)


def say(*args, verbose=False, **kwargs):
    if verbose:
        print("{}:".format(os.path.basename(__file__)), *args, file=sys.stderr, **kwargs)


def die(*args, **kwargs):
    debug(*args, **kwargs)
    sys.exit(1)


def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=DESCRIPTION,
                                     formatter_class=argparse.RawDescriptionHelpFormatter,)
    parser.add_argument('on',
                        type=str,
                        choices=['image', 'annotation'],
                        help="How to search and select images and annotations. If on is 'image', then evaluate the "
                             "expression on a per image basis and for images that satisfy the expression, select all "
                             "associated annotations. If on is 'annotation', then evaluate the expression on a per "
                             "annotation basis and for annotations that satisfy the expression, select all associated "
                             "images.")
    parser.add_argument('expression',
                        type=str,
                        help="General expression to search for images.",)
    parser.add_argument('-m', '--min',
                        action='store_const',
                        const=None,
                        default=4,
                        dest='indent',
                        help="Disable JSON pretty print.",)
    parser.add_argument('-v', '--verbose',
                        action='store_true',
                        help="More output to stderr.",)
    return parser.parse_args()


if __name__ == '__main__':
    main(get_args())
